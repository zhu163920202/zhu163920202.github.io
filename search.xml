<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js实战项目记录</title>
      <link href="/2019/12/03/js%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/12/03/js%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络模块封装</title>
      <link href="/2019/11/27/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/"/>
      <url>/2019/11/27/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>常见的网络请求方式：JSONP</p><p>主要通过<code>&lt;script&gt;</code>标签的<code>src</code>请求数据，解决了跨域访问问题，封装<code>jsonp</code>的核心在于监听<code>window</code>上的<code>jsonp</code>进行回调时的名称</p><p><code>axios</code></p>]]></content>
      
      
      <categories>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-router</title>
      <link href="/2019/11/24/Vue-router/"/>
      <url>/2019/11/24/Vue-router/</url>
      
        <content type="html"><![CDATA[<p>所有的组件都继承自<code>vue</code>类的原型</p><h3 id="vue-router基本使用"><a href="#vue-router基本使用" class="headerlink" title="vue-router基本使用"></a><code>vue-router</code>基本使用</h3><p>路由就是通过互联的网络把信息从源地址传输到目的地址的活动；</p><p>路由表本质是一个映射表，决定了数据包的指向；</p><p>后端路由：页面将请求路径交由服务器处理，服务器将渲染好的页面返回给客户端，此时客户端不需要单独加载任何<code>js</code>或<code>css</code>就可以直接显示页面；单页面富应用（<code>SPA</code>）：就是在前后端分离的基础上加一层前端路由；</p><p>前端路由的核心：改变<code>url</code>但是页面不进行整体的刷新；</p><ul><li><p><code>URL</code>的<code>hash</code>：即锚点（#），本质上是改变<code>window.location</code>的<code>href</code>属性，但是页面不发生刷新；</p></li><li><p>history接口是HTML5新增，有五种模式改变URL但不刷新页面（<code>pushState({},‘’,‘/path’}</code>,  <code>replaceState</code>, <code>go(number),</code> <code>history.back()(history.go(-1))</code>, <code>history.forward()( history.go(1) )</code>), 后三种模式相当于浏览器页面的前进和后退</p></li><li><p>默认情况，路径改变使用的是URL的hash；若使用HTML5的history默认，设置router的 <code>mode: ‘history’</code></p></li></ul><p><code>vue-router</code>是官方的路由插件，适应于构建单页面应用；是基于路由和组件的，路由用于设定访问路径，将路径和组件映射起来，页面路径的改变就是组件的切换；</p><ul><li><p>使用：<code>/src/router/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置路由相关的信息</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'../components/About'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../components/Home'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.通过vue.use(插件)，安装插件</span></span><br><span class="line">Vue.use(VueRouter)    <span class="comment">//内部会执行VueRouter.install</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建VueRouter对象</span></span><br><span class="line"><span class="keyword">const</span> routers = [</span><br><span class="line">    &#123; <span class="comment">//配置组件和路径的映射关系</span></span><br><span class="line">      path: <span class="string">''</span>,</span><br><span class="line">      redirect: <span class="string">'/About'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/About'</span>,</span><br><span class="line">      component: About</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/Home'</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 配置路由和组件之间的应用关系</span></span><br><span class="line">  routers,</span><br><span class="line">  mode: <span class="string">'history'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将router对象传入到vue实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li><li><p>创建路由组件 <code>/src/components/xxx.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    xxxxx</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;Home&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置组件和路径的映射关系</p></li><li><p>使用路由 <code>/src/app.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to=&quot;/About&quot; tag=&quot;button&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;router-link to=&quot;/Home&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>注：</p><p><code>&lt;router-link&gt;</code>标签是<code>vue-router</code>中内置的组件，会被渲染成一个<a>标签；</a></p><ul><li>属性to：指定跳转的路径</li><li>tag：指定渲染后的标签类型</li><li>replace：不会留下history记录</li><li>active-class：当<code>&lt;router-link&gt;</code>对应的路由匹配成功时会自动给当前元素设置一个<code>router-link-active</code>的class，<code>exact-active-class</code>与器类似，只是在精准匹配下才会出现的class</li></ul><p><code>&lt;router-view&gt;</code>标签会根据当前的路径，动态渲染出不同的组件，路由切换时切换的是其挂载的组件，其他内容不会发生改变</p></li></ul><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>将路由对应的组件打包成一个个的<code>js</code>代码块。只有在这个路由被访问的时候，才加载对应的组件;一个懒加载对应一个<code>js</code>文件</p><p><code>ES6</code>中写法</p><p><code>const xxx = () =&gt; import(&#39;../component/xxx.vue&#39;)</code></p><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 动态路径参数以 ：标记</span></span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 对于id不同的用户均用 User 组件进行渲染，参数值会被设置到`this.$router.params`,可以在每个组件内使用</span></span><br><span class="line"><span class="comment">// 输出当前用户的id</span></span><br><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt; User &#123;&#123; &amp;router.params.id &#125;&#125; &lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在一个路由中设置多段“路径参数”，对应的值都会设置到<code>$route.params</code>中</p><table><thead><tr><th align="center">模式</th><th align="center">匹配路径</th><th align="center"><code>$route.params</code></th></tr></thead><tbody><tr><td align="center">/user/:username/post/:post_id</td><td align="center">/user/lucky/post/123</td><td align="center">{username: ‘lucky’, post_id: 123}</td></tr></tbody></table><p><code>$route.query</code>: 是一个对象类型，表示URL查询参数。对于路径<code>/user?id=123</code>, 则有<code>$route.query.id==123</code>，如果没有查询参数，则是一个空对象</p><h3 id="vue-router嵌套路由"><a href="#vue-router嵌套路由" class="headerlink" title="vue-router嵌套路由"></a><code>vue-router</code>嵌套路由</h3><p>实现步骤：</p><ul><li>创建对应的子组件，并且在路由映射中配置对应的子路由</li><li>在组件内部使用<router-view>标签</router-view></li></ul><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a>$route 和 $router 的区别</h3><ul><li><code>$router</code> 为<code>VueRouter</code>实例，想要导航到不同的URL，则使用<code>$router.push</code>方法</li><li><code>$router</code> 为当前<code>router</code>跳转对象，可以用于获取<code>name, path, query, params</code>等</li></ul><h3 id="vue-router导航守卫"><a href="#vue-router导航守卫" class="headerlink" title="vue-router导航守卫"></a><code>vue-router</code>导航守卫</h3><p>导航：表示路由正在发生改变，导航守卫主要用来通过监听路由的离开和进入；</p><p>前置守卫<code>beforeEach(to, from, next)</code>：跳转前回调 (全局守卫)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title</span><br><span class="line">  next()  <span class="comment">//跳转到下一个钩子，也可以添加条件自定义</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>后置守卫<code>afterEach(to, from)</code>：跳转后回调,不需要主动调用<code>next()</code> (全局守卫)</p><p>全局守卫按照创建顺序调用，守卫是异步解析执行，此时导航在所有守卫resolve完之前一直处于等待中；</p><p>每个守卫方法接收三个参数：</p><ul><li><code>to：route</code> 即将要进入的目标路由对象</li><li><code>from</code>：当前导航正要离开的路由</li><li><code>next：</code>是函数类型，必须调用该方法来resolve这个钩子，执行效果依赖该方法调用你的参数</li></ul><p>路由独享守卫：</p><p>可以在路由配置上直接定义<code>beforeEnter</code>守卫，其与全局前置守卫的方法参数一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo               </span><br><span class="line">     meta: &#123;<span class="comment">// 元数据：描述数据的数据</span></span><br><span class="line">        title: <span class="string">"home"</span></span><br><span class="line">      &#125;</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// routes 配置中的每个路由对象都称为路由记录，路由记录是可以嵌套的，</span></span><br><span class="line"><span class="comment">//一个路由匹配到的所有路由记录会暴露为`$route`对象的`$route.matched`数组，可以遍历该数组来查询路由记录中的meta字段</span></span><br></pre></td></tr></table></figure><p>组件内的守卫：可以在组件内直接定义一下路由导航守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导航解析流程：</p><ul><li>导航被触发</li><li>在失活的组件里调用离开守卫</li><li>调用全局的<code>beforeEach</code>守卫</li><li>在重用组件中调用<code>beforeRouteUpdate</code> 守卫</li><li>在路由配置里调用<code>beforeEnter</code></li><li>解析异步路由组件</li><li>在被激活的组件里调用<code>beforeRouteEnter</code></li><li>调用全局的 <code>beforeResolve</code> 守卫</li><li>导航被确认</li><li>调用全局的 <code>afterEach</code> 钩子</li><li>触发DOM更新</li><li>用创建好的实例调用<code>beforeRouterEnter</code>守卫中传给<code>next</code>的回调函数</li></ul><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><code>keep-alive</code></h3><p> <code>keep-alive</code>是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染；</p><p>两个属性：</p><ul><li><code>include</code>：字符串或表达式类型，只有匹配的组件会被 缓存</li><li><code>exclude</code>： 。。。。任何匹配的组件都不会被缓存</li></ul><p><code>router-view</code>也是一个组件，如果直接包含在<code>keep-alive</code>内部，所有路径匹配到的视图组件都会被缓存</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2019/11/24/Vuex/"/>
      <url>/2019/11/24/Vuex/</url>
      
        <content type="html"><![CDATA[<p><code>Vuex</code>是专为<code>Vue.js</code>应用程序开发的状态管理模式，采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p><p>多个状态在多个页面进行共享时使用，在组件外部管理状态</p><img src="/2019/11/24/Vuex/vuex-%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E6%97%B6%E6%95%B0%E6%8D%AE%E6%B5%81.png" style="zoom:50%;"><p>Vuex应用的核心是store，相当于一个容器包含应用中大部分的状态（state）；</p><ul><li>Vuex的状态存储是响应式的，当Vue组件从store中读取状态时若store中的状态发生变化，则相应的组件也会更新；</li><li>不能直接改变store中的状态，==改变store中状态的唯一途径：显示的提交（commit）mutation。==</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">//插件注册</span></span><br><span class="line">Vue.use(vuex)</span><br><span class="line"><span class="comment">//创建store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> vue.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++       <span class="comment">//通过 state.count 来获取状态对象                            </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.commit(<span class="string">'increment'</span>)   <span class="comment">//通过store.commit方法触发状态更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在组件中调用store中的状态仅需要在计算属性中返回即可</span></span><br><span class="line"><span class="comment">//触发变化在组件的methods中提交mutation</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line"> methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="vuex中重要概念"><a href="#vuex中重要概念" class="headerlink" title="vuex中重要概念"></a><code>vuex</code>中重要概念</h3><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>单一状态树（单一数据源）</p><h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h4><p>Vuex允许在store中定义getter（像计算属性一样，返回值会根据它的依赖被缓存起来，只有依赖值发生变化时才会被重新计算）</p><p>Getter接收state作为第一个参数，getters作为第二个参数；会暴露为<code>store.getters</code>对象，可以以属性的形式访问值；也可以通过让getter返回一个函数，来实现给getter传参，通过方法访问时，每次都会进行调用而不会缓存结果</p><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>类似于事件，每个mutation都有一个字符串的事件类型和一个回调函数（实际进行状态更改的地方），会接收state作为第一个参数</p><p>Mutation必须是同步函数</p><p>Mutation更新数据时，如果携带一些额外的参数（称为mutation的载荷（payload））作为第二个参数，可以是一个对象</p><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action类似mutation，但是action提交的是mutation，而不是直接更改状态；action可以包含任意异步操作；</p><p>Action函数接受一个store实例具有相同方法和属性的context对象，可以调用<code>context.commit</code>提交一个mutation，或通过<code>context.state, context.getteres</code>来获取state和getters</p><p>Action通过<code>store.dispatch</code>方法触发</p><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>Vuex允许将store分割成模块，每个模块拥有自己的state, mutation, action, getter,甚至是嵌套子模块；</p><p>模块内部的mutation和getter接收的第一个参数是模块的局部状态对象</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>如果 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... <span class="comment"># 抽取出API请求</span></span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          <span class="comment"># 我们组装模块并导出 store 的地方</span></span><br><span class="line">    ├── actions.js        <span class="comment"># 根级别的 action</span></span><br><span class="line">    ├── mutations.js      <span class="comment"># 根级别的 mutation</span></span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       <span class="comment"># 购物车模块</span></span><br><span class="line">        └── products.js   <span class="comment"># 产品模块</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery</title>
      <link href="/2019/11/24/jQuery/"/>
      <url>/2019/11/24/jQuery/</url>
      
        <content type="html"><![CDATA[<p>常见的JS库：<code>jQuery, Prototype, YUI, Dojo, ExtJS, zepto</code>等，都是对原生JavaScript的封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 页面DOM加载完成的入口</span></span><br><span class="line">&#125;)</span><br><span class="line">  <span class="comment">// 方法二： </span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 页面DOM加载完成的入口</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>==DOM结构渲染完毕即可执行内部代码；相当于原生js中的<code>DOMContentLoaded</code>==</p><p><code>$</code>是<code>jQuery</code>的顶级对象，相当于原生中的<code>window</code></p><p><code>jQuery</code>对象：是利用<code>$</code>对DOM对象包装后的对象（伪数组形式存储）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  DOM对象转换为jQuery对象，用$对其进行包装</span></span><br><span class="line"> <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>);</span><br><span class="line"> <span class="keyword">var</span> jQuerydiv = $(div);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// jquery对象转换为DOM对象</span></span><br><span class="line"> <span class="comment">// 1. jquery对象[索引值]</span></span><br><span class="line"> <span class="keyword">var</span> domdiv1 = $(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"> <span class="comment">// 2.jquery对象.get(索引值)</span></span><br><span class="line"> <span class="keyword">var</span> domdiv2 = $(<span class="string">'div'</span>).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h3><ul><li><code>:first/:last</code> <code>$(&#39;li:first&#39;)</code>:获取第一个li元素</li><li><code>:eq(index)</code> :获取相应索引值的元素，<code>index</code>从0开始</li><li><code>:odd/:even</code>：获取索引号为奇偶数的元素</li><li><code>parent()</code>：查找父级</li><li><code>children(selector)</code>：子代选择器</li><li><code>find(selector)</code>：</li><li><code>siblings(selector)</code>：查找兄弟节点，不包括自己本身</li><li><code>nextAll([expr])</code>：查找当前元素之前的所有同辈元素</li><li><code>prevtAll([expr])</code></li><li><code>hasClass(class)</code></li><li><code>eq(index)</code></li></ul><h3 id="jQuery操作属性"><a href="#jQuery操作属性" class="headerlink" title="jQuery操作属性"></a>jQuery操作属性</h3><p><strong>元素固有属性值prop()</strong></p><ul><li>获取属性值：<code>prop(&#39;属性&#39;)</code></li><li>设置属性值：<code>prop(&#39;属性&#39;，&#39;属性值&#39;)</code></li><li>除了普通属性操作，更适合操作表单属性（<code>disabled/checked/selected</code>）</li></ul><p><strong>元素自定义属性attr()</strong></p><ul><li>获取属性：<code>attr(&#39;属性&#39;)</code> // 类似于原生<code>getAttribute()</code></li><li>设置属性：<code>attr(&#39;属性&#39;，&#39;属性值&#39;)</code> // 类似于原生<code>setAttribute()</code></li><li>也可以用于获取h5自定义属性</li></ul><p><strong>数据缓存data()</strong></p><p><code>data()</code>方法可以在指定的元素上存取数据，并不会修改DOM元素结构；一旦刷新页面，之前存放的数据将会被移除</p><ul><li>附加数据：<code>data(&#39;name&#39;, &#39;value&#39;)</code></li><li>获取数据：<code>data(&#39;name&#39;)</code></li><li>同时还可以读取HTML5自定义属性<code>data-index</code>，得到的是数字型</li></ul><h3 id="jQuery文本属性值"><a href="#jQuery文本属性值" class="headerlink" title="jQuery文本属性值"></a>jQuery文本属性值</h3><p><code>jQuery的文本属性值常见操作：html()/text()/val()</code> 分别对应JS中的<code>innerHTML/innerText/value</code></p><h3 id="jQuery元素操作"><a href="#jQuery元素操作" class="headerlink" title="jQuery元素操作"></a>jQuery元素操作</h3><p><strong>遍历元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">法一：</span><br><span class="line">$(<span class="string">'div'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index, domEle</span>) </span>&#123;...&#125;)</span><br><span class="line"><span class="comment">// 注：index是每个元素的索引号；domEle是每个DOM元素对象</span></span><br><span class="line">法二：</span><br><span class="line">$.each(object, <span class="function"><span class="keyword">function</span>(<span class="params">index, element</span>) </span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><p><strong>创建、添加、删除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建</span><br><span class="line">$(<span class="string">'&lt;li&gt;&lt;/li&gt;'</span>)  <span class="comment">//动态创建了一个li</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span> 内部添加</span><br><span class="line">element.append(<span class="string">'something'</span>)  <span class="comment">// 把内容添加到匹配元素内部最后面</span></span><br><span class="line">element.prepend(<span class="string">'something'</span>)  <span class="comment">// 前面</span></span><br><span class="line"><span class="number">2.2</span> 外部添加</span><br><span class="line">element.after(<span class="string">'something'</span>)  <span class="comment">// 将内容放到目标元素后面</span></span><br><span class="line">element.before(<span class="string">'something'</span>)</span><br><span class="line"><span class="string">`内部添加元素，生成后是父子关系；外部添加元素生成后是兄弟关系`</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 删除元素</span><br><span class="line">element.remove()  <span class="comment">// 删除匹配的元素本身</span></span><br><span class="line">element.empty()  <span class="comment">// 删除匹配的元素集合中所有的子节点</span></span><br><span class="line">element.html(<span class="string">''</span>)  <span class="comment">// 清空匹配的元素内容 `还可以设置内容`</span></span><br></pre></td></tr></table></figure><h3 id="jQuery尺寸和位置操作"><a href="#jQuery尺寸和位置操作" class="headerlink" title="jQuery尺寸和位置操作"></a>jQuery尺寸和位置操作</h3><table><thead><tr><th>语法</th><th>用法</th></tr></thead><tbody><tr><td>width() / height()</td><td>取得匹配元素宽度和高度值，只有 width/height</td></tr><tr><td>innerwidth() / innerheight()</td><td>包括padding</td></tr><tr><td>outerwidth() / outerheight()</td><td>包括padding border</td></tr><tr><td>outerwidth(true) / outerheight(true)</td><td>包括padding, border, margin</td></tr></tbody></table><p>注：参数为空则是获取相应值，如果为数字则修改响应值，可不必写单位</p><p><strong>位置操作</strong></p><ol><li><p>offset() 设置或获取元素偏移</p><ul><li><p>设置或返回元素相对于文档的偏移坐标，与父级无关</p></li><li><p><code>offset().top / offset.left()</code>：获取距离文档顶部、左侧的距离</p></li><li><p>可以设置元素的偏移：<code>offset({ top: 10, left: 30 })</code></p></li></ul></li><li><p>position() 获取元素偏移</p><ul><li><p>用于返回被选元素==相对于带有定位的父元素偏移坐标==，如果父级没有定位，则以文档为准，只能用于获取</p></li><li><p><code>position().left / position().top</code>： 获取距离定位父级的左，顶部距离</p></li></ul></li><li><p>scrollTop() / scrollLeft() 设置或获取元素被卷去的头部和左侧</p></li></ol><h3 id="jQuery注册事件"><a href="#jQuery注册事件" class="headerlink" title="jQuery注册事件"></a>jQuery注册事件</h3><p><code>$(&#39;div&#39;).click(function() {...})</code> 和原生基本一致<code>mouseover/mouseout/blur/focus/change/keydown/keyup/resize/scroll</code></p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p><strong>on() 绑定事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定多个事件</span></span><br><span class="line">$(<span class="string">'div'</span>).on(&#123;</span><br><span class="line">  mouseover: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;,</span><br><span class="line">  mouseout: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;,                    </span><br><span class="line">   click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;                   </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果事件处理程序相同</span></span><br><span class="line">$(<span class="string">'div'</span>).on(<span class="string">'mouseover mouseout'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><p>事件委派：把原来添加给子元素身上的事件绑定到父元素身上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><p>动态创建的元素，<code>click</code>不能绑定事件，on 可以给动态生成的元素绑定事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).qppend(<span class="string">'&lt;p&gt;dynamic&lt;/p&gt;'</span>);</span><br><span class="line">$(<span class="string">'div'</span>).on(<span class="string">'click'</span>, <span class="string">'p'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><p><strong>off()解绑事件</strong></p><p><code>jQuery中多种事件解绑方法：die()/updelegate()/off()</code></p><p><code>off()</code>方法可以移除通过<code>on()</code>方法添加的事件处理程序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).off()    <span class="comment">// 解绑p元素的所有时间处理程序</span></span><br><span class="line">$(<span class="string">'p'</span>).off(<span class="string">'click'</span>)    <span class="comment">// 解绑p元素上的点解事件</span></span><br><span class="line">$(<span class="string">'ul'</span>).off(<span class="string">'click'</span>, <span class="string">'li'</span>)    <span class="comment">// 解绑事件委托</span></span><br><span class="line"></span><br><span class="line"><span class="string">`如果有的事件只想触发一次，可以使用one()绑定事件`</span></span><br></pre></td></tr></table></figure><p><strong><code>trigger()</code>自动触发事件</strong></p><ul><li><code>element.trigger(&#39;事件&#39;)</code></li><li><code>element.triggerHandler(事件)</code>：不会触发元素的默认行为</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.on(events, [selector], <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault(); <span class="comment">// 阻止默认行为</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 同上</span></span><br><span class="line">  event.stopPropagation(); <span class="comment">// 阻止冒泡</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="jQuery中trigger-和triggerHandler-区别"><a href="#jQuery中trigger-和triggerHandler-区别" class="headerlink" title="jQuery中trigger() 和triggerHandler()区别"></a>jQuery中trigger() 和<code>triggerHandler()</code>区别</h4><p><code>trigger</code>：在每一个匹配的元素上触发某类事件;</p><ul><li>会导致浏览器的同名的默认行为的执行</li></ul><p><code>triggerHandler</code>：触发指定的事件类型上所有绑定的处理函数</p><ul><li>只会触发匹配对下集合中的第一个元素的事件处理函数，不会产生事件冒泡</li></ul><h3 id="jQuery拷贝对象"><a href="#jQuery拷贝对象" class="headerlink" title="jQuery拷贝对象"></a>jQuery拷贝对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.extend([deep], target, object1, [objectn])</span><br><span class="line">deep 默认<span class="literal">false</span>, 为浅拷贝；<span class="literal">true</span> 为深拷贝；<span class="string">`浅拷贝目标对象引用的是被拷贝对象的地址，修改目标对象会影响被拷贝对象；深拷贝则为完全克隆，修改目标对象不会影响被拷贝对象`</span></span><br><span class="line">target：要拷贝的目标对象</span><br></pre></td></tr></table></figure><p>jQuery 插件常用的网站：</p><ol><li><p>jQuery 插件库  <a href="http://www.jq22.com/" target="_blank" rel="noopener">http://www.jq22.com/</a>     </p></li><li><p>jQuery 之家   <a href="http://www.htmleaf.com/" target="_blank" rel="noopener">http://www.htmleaf.com/</a> </p><p>jQuery 插件使用步骤：</p></li><li><p>引入相关文件。（jQuery 文件 和 插件文件）    </p></li><li><p>复制相关html、css、js (调用插件)。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2019/11/24/HTML/"/>
      <url>/2019/11/24/HTML/</url>
      
        <content type="html"><![CDATA[<p><code>web</code>标准有三层结构：结构（<code>html</code>）、表现（<code>css</code>）和行为（<code>javascript</code>）；理想状态下三者独立放入不同的文件中</p><p><code>HTML: hyper text markup language</code> 超文本标记语言，是一套标记标签；超文本因为可以加入图片、声音、动画、多媒体等内容（超文本限制），还可以从一个文件跳到另一个文件（超链接文本）。</p><p><code>&lt;hr /&gt;</code>单标签，页面中显示为一条水平线；</p><p><code>&lt;br /&gt;</code>换行</p><p><code>&lt;img src=&quot;图片路径&quot; alt=&quot;图片不能显示时的替换文本&quot; title=&quot;鼠标悬停时的显示内容&quot; /&gt;</code></p><p><code>&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;</code></p><ul><li>当标签应用<code>href</code>属性时，就具有了超链接的功能，外部链接或内部链接（直接链接内部页面名称即可）；</li><li><code>target</code>：用于指定连接页面的打开方式，<code>_self</code>默认方式，原窗口打开，<code>_blank</code>:在新窗口打开；</li></ul><p>锚点定位：通过创建锚点链接，用户能够快速定位目标内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- step1: 使用相应的id名标注跳转目标的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"biaoti"</span>&gt;</span>this is title.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- step2：使用&lt;a&gt;标签创建连接文本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#id"</span>&gt;</span>target<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;base target=&quot;_blank&quot; /&gt;</code>：base标签放在<head>标签内；可以设置整体连接的打开状态</head></p><p><code>&lt;pre&gt;&lt;/pre&gt;</code>: pre标签可以定义预格式化的文本；被包裹在pre标签内的文本通常会保留空格和换行符，文本也会呈现为等宽字体；少用不好整体控制</p><p>特殊字符：空格：<code>&amp;nbsp;</code>   <code>&lt; &amp;lt;</code>   &gt; <code>&amp;gt;</code></p><p><code>XHTML</code>可扩展超文本标记语言(extensible hypertext markup language)，是更严格更纯净的的HTML版本，与h4几乎相同，是一个W3C标准</p><h3 id="表格：用来展示数据，可让数据显示整齐规范；"><a href="#表格：用来展示数据，可让数据显示整齐规范；" class="headerlink" title="表格：用来展示数据，可让数据显示整齐规范；"></a>表格：用来展示数据，可让数据显示整齐规范；</h3><p>属性：（三参为0：指<code>border, cellpadding, cellspacing</code>为0）</p><ul><li><code>cellspacing</code>: 设置单元格之间的空白距离，默认2px</li><li><code>cellpadding</code>：设置单元给内容与边框之间的距离，默认1px；</li><li><code>align</code>: 设置表格在网页中的对齐方式</li></ul><p>表头标签<code>th</code>（也是一个单元格）与<code>td</code>类似，一般位于表格的第一行或第一列，文本加粗居中显示，直接替换相应额<code>td</code>标签即可</p><p><code>&lt;caption&gt;</code>元素，定义表格标题，居中显示在表格之上；必须紧跟在<code>&lt;table&gt;</code>标签之后</p><h3 id="表单：用来收集用户信息；"><a href="#表单：用来收集用户信息；" class="headerlink" title="表单：用来收集用户信息；"></a>表单：用来收集用户信息；</h3><h3 id="列表：用来布局，让页面布局整齐规范"><a href="#列表：用来布局，让页面布局整齐规范" class="headerlink" title="列表：用来布局，让页面布局整齐规范"></a>列表：用来布局，让页面布局整齐规范</h3>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>value，innerHT，innerText区别</title>
      <link href="/2019/11/24/value%EF%BC%8CinnerHT%EF%BC%8CinnerText%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/24/value%EF%BC%8CinnerHT%EF%BC%8CinnerText%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="获取标签内容"><a href="#获取标签内容" class="headerlink" title="获取标签内容"></a>获取标签内容</h3><ul><li><code>innerHTML:</code>获取标签内的所有内容，按照代码格式输出标签内容</li><li><code>innerText:</code>获取去除标签的其他内容，无格式直接输出，对于单标签无法识别</li><li><code>value</code>：获取标签的<code>value</code>属性值</li></ul><h3 id="修改标签内容"><a href="#修改标签内容" class="headerlink" title="修改标签内容"></a>修改标签内容</h3><ul><li><code>innerHTML:</code>相当于给标签中加入<code>html</code>代码，会进行标签解析</li><li><code>innerText:</code>相当于给标签中加入文本内容</li><li><code>value</code>：修改控件的显示内容</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node</title>
      <link href="/2019/11/24/node/"/>
      <url>/2019/11/24/node/</url>
      
        <content type="html"><![CDATA[<p><code>npm init -y</code>：生成<code>package.json</code>文件，项目描述文件，记录了当前项目信息，如项目名称、版本、作者、当前项目依赖<code>dependencies</code>（项目开发阶段和线上运营阶段都需要依赖的第三方包）等</p><p><code>devDependencies</code>: 开发依赖，仅在项目开发阶段需要</p><p><code>package-lock.json</code>文件：锁定包的版本，确保下载时不会因为包版本不同而产生问题；加快下载速度，因为该文件中记录了项目所依赖的第三方包的树状结构和包的下载地址，只需要直接下载即可</p><p><strong>Node.js中模块加载机制</strong></p><ol><li>当模块有路径没有后缀时<code>require(&#39;./find&#39;)</code><ul><li>先找同名<code>js</code>文件，再找同名文件夹</li><li>如果找到了同名文件夹，找文件夹中的<code>index.js</code></li><li>如果文件夹中没有<code>index.js</code>就会去当前文件夹中的<code>package.json</code>文件中查找<code>main</code>选项中的入口文件</li><li>如果指定的入口文件不存在或者没有指定入口文件，就会报错，模块没有找到</li></ul></li></ol><p><strong>HTTP请求与响应处理</strong></p><ol><li><p>get请求参数</p><ul><li><p>参数被放置在浏览器地址栏中</p></li><li><p>参数获取借助系统模块URL</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">const</span> app = http.createServer()</span><br><span class="line">app.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 将URL路径的各个部分解析出来并返回对象</span></span><br><span class="line">  <span class="comment">// true表示将参数解析为对象格式</span></span><br><span class="line">  <span class="keyword">let</span> &#123;query&#125; = url.parse(req.url, <span class="literal">true</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(query)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>post请求参数（表单提交）</p><ul><li><p>参数放置在请求体中进行传输</p></li><li><p>获取post参数需要使用data事件和end事件</p></li><li><p>使用<code>querystring</code>系统模块将参数转换为对象格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line">app.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> postData = <span class="string">''</span></span><br><span class="line">  <span class="comment">// 监听参数传输事件  </span></span><br><span class="line">  req.on(<span class="string">'data'</span>, (arg) =&gt; postData += arg)</span><br><span class="line">  <span class="comment">// 监听参数传输完毕事件</span></span><br><span class="line">  req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(querystring.parse(postData))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>同步API：只有当前API执行完成后，才能继续执行下一个API，可以从返回值中获得API执行的结果</p><p>异步API: 当前API的执行不会阻塞后续代码的执行</p><p><code>Promise</code>: 目的是解决<code>Node.js</code>异步编程中回调地狱的问题</p><p>异步函数时异步编程语法的终极解决方案，可以将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了</p><p><strong><code>async</code>关键字</strong></p><ul><li>普通函数前加<code>async</code>关键字即可变成异步函数</li><li>异步函数默认返回<code>Promise</code>对象</li><li>在异步函数内使用return关键字进行结果返回，结果会被包裹在<code>promise</code>对象中，<code>return</code>关键字代替了<code>resolve</code>方法</li><li>在异步函数内部使用<code>throw</code>关键字抛出程序异常</li><li>调用异步函数再链式调用<code>then</code>方法获取异步函数执行结果</li><li>调用异步函数再链式调用<code>catch</code>方法获取异步函数执行的错误信息</li></ul><p><strong><code>await</code>关键字</strong></p><ul><li>只能出现在异步函数中</li><li>后面只能写promise对象 <code>await promise对象</code></li><li>暂停异步函数向下执行，直到<code>promise</code>返回结果</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js</title>
      <link href="/2019/11/24/js/"/>
      <url>/2019/11/24/js/</url>
      
        <content type="html"><![CDATA[<p>函数实参个数小于形参个数时，多的形参定义为<code>undefined</code> ，结果为<code>NaN</code>；</p><p>函数使用<code>return</code>语句时，会停止执行，并返回指定的值；如果没有<code>return</code>，返回值是<code>undefined</code>,同时结束当前的函数体中的代码；</p><p>所有函数都内置了一个<code>arguments</code>对象，是一个伪数组，其中存储了传递的所有实参；具有<code>length</code>属性，按索引方式进行存储数据，但是不具有数组的其他方法；</p><p>函数体内部<code>var</code>声明的变量是局部变量，只能在函数内部使用；</p><ul><li>全局变量：任意地方都可以使用，只有在浏览器关闭时才会被销毁，比较占内存；</li><li>局部变量：只有在函数体内部使用，当其所在代码块被执行时，会被初始化，代码块运行结束就会被销毁，所以更节省内存；</li></ul><p>作用域链：内部函数可以访问外部函数变量的机制；</p><p>预解析：在当前作用域下，JS代码执行前浏览器会默认把带有<code>var/function</code>声明的变量在内存中进行提前声明或定义（变量提升只提升声明，不提升赋值；函数声明会提升到当前作用域的最上面，但不会调用函数）</p><p>JS中的对象分为：自定义对象、内置对象（<code>Math, Date, Array, String...</code>）和浏览器对象；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定范围内的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max-min+<span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">'this is content.'</span>;</span><br><span class="line"><span class="comment">// 从索引5开始，取6个字符；省略则取所有</span></span><br><span class="line"><span class="keyword">var</span> res = str1.substr(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"></span><br><span class="line">slice(start, end); <span class="comment">// 截取，[start, end)   类似 substring(start, end) (不接受负值)</span></span><br></pre></td></tr></table></figure><p>简单数据类型：（基本数据类型、值类型）在存储变量中存储的是值本身，包括<code>string, number, boolean, undefined, null</code></p><p>复杂数据类型：（引用类型）变量中存储的仅仅是地址（引用），通过<code>new</code>关键字创建的对象，<code>Object, Array, Date...</code></p><p>栈：由操作系统自动分配存放函数的参数值、局部变量等，操作方式类似于数据结构中的栈，简单数据类型存放到栈中；堆：存放复杂数据类型，一般由程序员分配释放，若没有人为释放，则由垃圾回收机制回收；</p><p>注：<code>getElementByTagName()</code>: 返回一个对象数组，元素顺序按照其在文档中的顺序；<code>querySelector()</code>: 返回指定<code>css</code>选择器元素的第一个子元素; <code>query</code>选择符选出来的元素及元素数组是静态的，而<code>getElement</code>方法选出来的元素是动态的，会随着文档操作而改变。</p><h3 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h3><p>通过class关键字创建类，通常类名首字母大写；类中有个<code>constructor</code>函数，可以接收实例传递的参数，并返回实例对象；只要用 new 生成实例时就会自动调用<code>constructor</code>函数，即使不定义类也会自动生成这个函数；</p><h3 id="改变函数内部this指向"><a href="#改变函数内部this指向" class="headerlink" title="改变函数内部this指向"></a>改变函数内部this指向</h3><p>==定时器函数和立即执行函数的this指向<code>window</code>==</p><ol><li><p>call</p><p><code>fn.call(target,args1, args2...)</code>：此时this指向的是对象target</p></li><li><p>apply: 使用数组传递参数</p><p><code>fn.apply(target, [args1, args2...])</code></p></li><li><p>bind</p><p><code>var f = fn.bind(target, args1, args2...)</code></p><p><code>bind()</code>方法不会调用函数，但是能改变函数内部this的指向，使用时需要调用新函数<code>f()</code></p></li></ol><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ol><li>为脚本开启严格模式，可以将整个脚本放在一个立即执行匿名函数中，独立创建一个作用域而不影响其他script脚本</li><li>为函数开启严格模式，需要将<code>use strict</code>声明放在函数体所有语句之前</li></ol><p>严格模式下不允许使用未声明变量；不允许删除变量；全局作用域中函数的this是undefined；构造函数不加new调用this指向的是undefined，赋值会报错；定时器this还是指向window</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包（closure）:有权访问另一个函数作用域中变量的函数</p><p>函数外部不可以使用局部变量；当函数执行完毕本作用域内的局部变量会销毁</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D电商网站布局总结</title>
      <link href="/2019/11/24/%E5%93%81%E4%BC%98%E8%B4%AD%E5%AE%9E%E6%88%98/"/>
      <url>/2019/11/24/%E5%93%81%E4%BC%98%E8%B4%AD%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>网站<code>ico</code>图片，<a href="http://www.bitbug.net/" target="_blank" rel="noopener">借助第三方转换网站</a>，放在<code>head</code>标签中，为了兼容性通常将其放在根目录下，命名为<code>favicon.ico</code>，<code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;  type=&quot;image/x-icon&quot;/&gt;</code> <code>type</code>可省略</p></li><li><p>网站优化三大标签</p><p>​        <code>SEO: search engine optimization</code>(搜索引擎优化)；指通过对网站进行站内优化、网站结构调整、网站内容建设、网站代码优化等和站外优化，从而提高网站的关键词排名以及产品的曝光度。</p><p>（1）<code>titile</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网站名（产品名）-网站的介绍<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）<code>description</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"网站的总体业务和主体介绍"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>(3) <code>keywords</code></p><meta name="“keywords”" content="“关键词6-8个”"></li><li><p>字体图标</p><p>可以和图片一样改变透明度、旋转等，但其本质是文字，可以随意改变颜色、产生阴影、透明效果等，体积小，几乎支持所有的浏览器</p><p>字体图标转换网站：<a href="http://icomoon.io，" target="_blank" rel="noopener">http://icomoon.io，</a> <a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a></p></li><li><p><code>logo</code>优化</p><ul><li><p><code>logo</code>中放<code>h1</code>标签，可以提权，告诉搜索引擎这里很重要</p></li><li><p><code>h1中放a</code></p><ul><li>给<code>a</code>一个大小和<code>logo</code>的背景图片</li><li><code>a</code>内部放文字，但是不要显示出来，为了搜索引擎收录<ol><li><code>text-indent</code>将文字移到盒子外面，然后<code>overflow:hidden;</code></li><li>用<code>font-size: 0;</code></li></ol></li></ul></li><li><p>给连接一个<code>title</code>，鼠标放到上面即可看到提示文字</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2019/11/24/CSS/"/>
      <url>/2019/11/24/CSS/</url>
      
        <content type="html"><![CDATA[<p><code>em</code>：相对长度单位，是相对于当前对象内文本的字体尺寸</p><p><code>px</code>也为相对长度单位，谷歌浏览器字体大小默认<code>16px</code>,不同浏览器会有区别</p><p>==<code>font-weight</code>设置字体粗细，没有单位==；<code>normal</code>相当于400；<code>bold</code>相当于700</p><p>综合字体设置： <code>font: font-style font-weight font-size/line-height font-family;</code> <code>font-size , font-family</code>属性不能省略</p><p><code>text-indent</code>首行缩进，属性值可以为不同单位的数值，推荐<code>em</code>字符宽度的倍数</p><p>常见的块级元素：<code>h1-h6, p , div, ul, ol, li</code>;</p><p>常见的行内元素： <code>a i span strong em del s ins</code> <code>img input td （行内块元素）</code></p><p>背景附着：即背景是滚动或固定，<code>background-attachment: scroll|fixed;</code></p><p><code>border-collapse: collapse;</code>  相邻边框合并在一起</p><p>外边距塌陷，只发生在垂直方向上，对应并列的盒子尽量只给其中一个设置<code>margin-top/bottom</code>; 对于嵌套块元素，如果父元素没有上内边距及边框，会发生塌陷，解决：1.为父盒子添加<code>padding</code>  2. 为父盒子添加边框 3.为父元素设置<code>overflow: hidden;</code></p><p><code>css规范</code>：一般情况下，选择器的嵌套层级应不大于三级，位置靠后的限定条件尽可能精确</p><p><code>css</code>布局的三种机制：标准文档流，浮动和定位</p><p>行内块：虽然可以实现多个元素一行显示，但是中间会有空白缝隙；</p><p>浮动的元素会脱离标准流，任何元素都可以浮动，浮动元素会生成一个块级框，如果父级宽度小于浮动的盒子，多出的盒子会另起一行对齐；浮动元素会改变<code>display属性，</code>类似转换为了行内块，但是元素之间没有空隙；</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>主要是为了解决父级元素因为子级浮动引起内部高度为0的问题。清除浮动后，父元素就会根据浮动的盒子自动检测高度，父元素有了高度就不会影响下面的标准流了；</p><p>清除浮动的四种方法：</p><ol><li><p>额外标签法</p><p>W3C推荐，在浮动元素末尾添加一个空的标签，<code>标签选择器{ clear: both; }</code></p></li><li><p>父级添加<code>overflow</code>属性</p><p><code>overflow: hidden | auto | scroll;</code>都可以实现，内容增多时不会自动换行，但是溢出的内容无法显示</p></li><li><p>伪元素法，父元素添加 <code>clearfix</code>类名</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: 1;   /* ie6, 7专有 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>父级双伪元素法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常见图片格式"><a href="#常见图片格式" class="headerlink" title="常见图片格式"></a>常见图片格式</h3><ul><li><p>jpg</p><p><code>JPEG（.jpg)</code>对色彩的信息保留较好，高清，颜色较多，产品类的图常使用</p></li><li><p>gif</p><p>最多只能存储256色，通常用来显示简单图形及字体，可以保存透明背景和动画效果</p></li><li><p><code>png</code></p><p>是一种新兴的网络图形格式，结合了GIF和jpg的优点，具有存储形式丰富的特点，能够保持透明背景</p></li><li><p><code>psd</code></p><p><code>ps</code>专用格式，可以存放图层、通道、遮罩等多种设计草稿</p></li></ul><h3 id="CSS书写顺序"><a href="#CSS书写顺序" class="headerlink" title="CSS书写顺序"></a>CSS书写顺序</h3><ol><li>布局定位属性：<code>display/position/float/clear/visibility/overflow</code></li><li>自身属性：<code>width/height/margin/padding/border/background</code></li><li>文本属性：<code>color/font/text-decoration/text-align/vertical-align/white-space/break-word</code></li><li>其他属性（<code>css3</code>）: <code>content/cursor/border-radius/box-shadow/text-shadow/background</code></li></ol><h3 id="布局流程"><a href="#布局流程" class="headerlink" title="布局流程"></a>布局流程</h3><p>为了提高网页制作效率，通常遵循以下布局流程：</p><ol><li>确定页面的版心（可视区）</li><li>分析页面中的行模块，以及每个行模块中的列模块</li><li>制作<code>HTML</code>结构</li><li>运用盒子模型原理，通过<code>div+css</code>布局控制网页各模块</li></ol><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>相对定位：元素相对于原来在标准流中的位置来定位；==原来在标准流中的区域继续占有==，后面的盒子仍然以标准流的方式对待它；</p><p>绝对定位：元素以带有定位的父级元素来移动位置；完全脱标，不占位置，若父元素没有定位，则以浏览器为准定位；==子绝父相==</p><p>固定定位：是绝对定位的一种特殊形式，完全脱标，不占位置，==只和浏览器可视窗口有关==，不随滚动条滚动，与父元素无关</p><p>注：绝对定位/固定定位的盒子不能通过<code>margin: auto;</code>来设置水平居中；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 绝对定位的盒子水平居中 */</span></span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span>: 50%;</span><br><span class="line">margin-left: - 自身宽度/2;</span><br></pre></td></tr></table></figure><p><code>z-index</code> 只能用于相对定位、绝对定位、固定定位的盒子，对于其他标准流、浮动和静态定位无效；值为整数可正可父，值越大，盒子越靠上。</p><p><strong>定位改变<code>display</code>属性，与浮动类似（默认转换为行内块），一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子设置宽高；且不会触发外边距合并问题。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置圆角 */</span></span><br><span class="line"><span class="selector-tag">border-radius</span>: 左上角 右上角 右下 左下；</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单个设置圆角 */</span></span><br><span class="line"><span class="selector-tag">border-top-left-radius</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-top-right-radius</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-right-radius</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-left-radius</span><span class="selector-pseudo">:2</span> 0<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p><code>display: none;</code> 隐藏对象，隐藏后，不再保留位置；<code>display: block;</code>除了可以将元素转换为块级元素，同时还有显示元素的意思。</p><p><code>visibility: visible | hidden;</code> 显示隐藏元素，隐藏后元素的位置会保留；</p><p>鼠标样式：<code>cursor: pointer（手）; move（四向箭头）; text; not-allowed;</code></p><p>去掉轮廓线：<code>outline: 0 \ none;</code></p><p>防止文本域拖拽：<code>&lt;textarea style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt;</code></p><p>垂直对齐<code>vertical-align： baseline |top |middle |bottom</code>：只对行内元素或行内块元素有作用，常用来控制图片/表单与文字的对齐；因为图片默认与文字基线对齐，所以还可以用来去除图片底部白色缝隙（只要不与基线对齐即可）– 或者将图片转换为块级元素也可去除底部白色缝隙；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 溢出文字用省略号表示 */</span></span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;  <span class="selector-tag">--</span>强制在一行显示文本，默认<span class="selector-tag">normal</span>自动换行</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;  <span class="selector-tag">--</span>显示省略标记</span><br><span class="line"><span class="comment">/* clip;不显示省略标记（……）只是简单的裁切*/</span></span><br></pre></td></tr></table></figure><p>微信滑动门：核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>导航栏内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>margin</code>取负值可实现压住相邻盒子的边框</p><p><code>CSS三角形</code>：</p><ul><li><code>css</code>边框可以模拟三角形效果；宽高为0；设置四个边框的颜色，不需要的则设置为<code>transparent</code>; 为了照顾兼容性，低版本的浏览器会加上<code>font-size:0; line-height: 0;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2019/11/24/Promise/"/>
      <url>/2019/11/24/Promise/</url>
      
        <content type="html"><![CDATA[<p><code>Promise</code>是异步编程的一种解决方案（优雅），一般有异步操作时，使用promise进行封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">//成功调用 resolve函数，失败调用reject-----链式编程</span></span><br><span class="line">    resolve(data)                  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123; 成功时进行的相应的处理&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; 失败时的处理 &#125;)</span><br><span class="line"></span><br><span class="line">也可以在then（）中传递两个函数，成功时调用参数一，失败调用参数二</span><br></pre></td></tr></table></figure><p>Promise三种状态：pending（等待状态，正在进行网络请求或者定时器时间未到），fulfill（满足，主动回调resolve时处于该状态，并且会回调then），reject（拒绝状态，回调reject时处于该状态，并且回调catch）</p><p><code>promise.all()</code>包装多个异步异步请求，所有异步请求都成功时会执行.then() 函数</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5+CSS3</title>
      <link href="/2019/11/24/H5+CSS3/"/>
      <url>/2019/11/24/H5+CSS3/</url>
      
        <content type="html"><![CDATA[<p>广义的<code>h5</code>拥有一个强大的技术集，包括<code>html5, css3, javascript.</code>拓展内容：语义化标签、本地存储、兼容特性、2D, 3D、动画、过渡、css3特性、性能与集成</p><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p><code>header, nav, artical, section, aside, footer...</code> ==ie9浏览器需要把语义化标签转换为块级元素==</p><p><strong>多媒体音频标签</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"media/陆虎-雪落下的声音.mp3"</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> <span class="attr">loop</span>=<span class="string">"loop"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span> --&gt;</span><br><span class="line">  &lt;audio controls=<span class="string">"controls"</span>&gt;</span><br><span class="line">    &lt;!-- 因为不同浏览器支持不同的格式，通常会为同一音频内容准备多个文件 --&gt;</span><br><span class="line">    &lt;!-- Chrome 中禁用autoplay 属性 --&gt;</span><br><span class="line">    &lt;source src=<span class="string">"media/陆虎-雪落下的声音.mp3"</span> type=<span class="string">"audio/mpeg"</span>&gt;</span><br><span class="line">    &lt;source src=<span class="string">"media/陆虎-雪落下的声音.mp3"</span> type=<span class="string">"audio/ogg"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/audio&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><p><strong>多媒体视频标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">width</span>=<span class="string">"npx"</span> <span class="attr">loop</span>=<span class="string">"loop"</span> <span class="attr">poster</span>=<span class="string">"imgurl"</span> <span class="attr">preload</span>=<span class="string">"auto/none"</span> <span class="attr">muted</span>=<span class="string">"muted"</span> &gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>chrome</code>浏览器需要添加<code>muted</code>来解决自动播放问题</li><li>可以通过宽高设置播放器界面大小</li><li><code>preload</code>规定是否预加载视频，如果设置了<code>autoplay</code>则忽略该属性</li><li><code>poster</code>：加载等待的画面图片</li><li><code>muted</code>：静音播放</li></ul><p><strong>新增input标签</strong></p><p><code>type=&quot;email/url/date/time/month/week/number/tel/search/color&quot;</code></p><p><strong>新增表单属性</strong></p><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td><code>required</code></td><td><code>required</code></td><td>必填，不能为空</td></tr><tr><td><code>placeholder</code></td><td>提示文本</td><td>提示信息，存在默认值将不显示</td></tr><tr><td><code>autofocus</code></td><td><code>autofocus</code></td><td>页面加载完成自动聚焦到指定表单</td></tr><tr><td><code>autocomplete</code></td><td><code>off/on</code></td><td>自动完成允许浏览器预测对字段的输入，当用户在字段开始键入时，浏览器会根据之前输入的值，显示字段填写的选项。默认on，需要在表单内同时加上name属性，同时成功提交，</td></tr><tr><td><code>multiple</code></td><td><code>multiple</code></td><td>可以选择多个文件提交</td></tr></tbody></table><p><strong>css3属性选择器</strong></p><table><thead><tr><th>选择符</th><th>功能</th></tr></thead><tbody><tr><td><code>E[attr]</code></td><td>选择具有<code>attr</code>属性的E元素</td></tr><tr><td><code>E[attr=&quot;val&quot;]</code></td><td></td></tr><tr><td><code>E[attr^=&quot;val&quot;]</code></td><td></td></tr><tr><td><code>E[attr$=&quot;val&quot;]</code></td><td></td></tr><tr><td><code>E[attr*=&quot;val&quot;]</code></td><td></td></tr></tbody></table><p><strong>结构伪类选择器</strong></p><ul><li><code>:nth-child(n)</code>: 选择父元素里面的第n个子元素，不考虑类型</li><li><code>:nth-of-type(n)</code>: 选择指定类型的元素</li></ul><p><strong>伪类选择器</strong></p><p><code>::before</code>: 在元素内部的前面插入内容</p><p><code>::after</code>： 在元素内部的后面插入内容</p><p>注：必须有<code>content</code>属性；创建的元素属于行内元素，在DOM树中查不到；和标签选择器一样权重为1</p><h3 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h3><p><strong>translate</strong></p><p>主要指水平、垂直方向上的移动；==不影响其他元素的位置==；对行内标签没有效果；其中100%单位，是相对于本身的宽高进行计算的；</p><p><strong>rotate</strong></p><p><code>transform: rotate(ndeg);</code>正值时顺时针旋转，默认旋转中心为元素的中心点；</p><p>设置旋转中心：</p><p><code>transform-origin: x  y;</code> 值可以设置为百分比、像素值或方位名词</p><p><strong>scale</strong></p><p><code>transform: scale(x, y);</code> 值没有单位，表示宽高的放大倍数；默认以中心点缩放，而且不影响其他盒子；如果只有一个值则表示同时修改宽高；</p><p>同时使用多个转换，顺序会影响转换效果，将位移放到最前面 <code>transform: translate() rotate() scale()</code></p><h3 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h3><p><strong>3D位移</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 三个值均不能省略，不需要则用0进行填充 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate3d</span>(<span class="selector-tag">x</span>, <span class="selector-tag">y</span>, <span class="selector-tag">z</span>);</span><br></pre></td></tr></table></figure><p><strong>3D旋转</strong>  </p><p><code>rotate3d(x, y, z, 45deg);</code> 沿着自定义轴旋转45度</p><p><strong>透视</strong></p><p>==如果想要网页产生3D效果需要透视==   <code>perspective: 1000px;</code></p><p><code>3D呈现 transform-style: perserve-3d/flat;</code> 控制子元素是否开启立体空间，默认flat；</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H5 </tag>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五大主流浏览器四大内核</title>
      <link href="/2019/11/24/%E4%BA%94%E5%A4%A7%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2019/11/24/%E4%BA%94%E5%A4%A7%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>浏览器内核组成：渲染引擎（<code>rendering engine</code>) 和 <code>JS</code>引擎。负责获取网页内容（<code>HTML</code>，<code>XML</code>，图像等）整理信息（加入<code>css</code>等），计算网页的显示方式，然后输出至显示器。不同浏览器对网页语法解释不同，所以渲染效果也不同。<code>js</code>引擎：用于解析执行<code>js</code>语言来实现网页的动态效果。</p><p>五大浏览器四大内核：</p><ol><li><code>IE</code>浏览器：<code>Trident</code>内核，俗称IE内核</li><li><code>Chrome</code>浏览器：统称为Chrome内核，以前基于<code>webkit</code>，现在基于<code>blink</code>内核</li><li><code>Firefox</code>：俗称<code>Firefox</code>内核，<code>gecko</code>内核</li><li><code>Safari</code>浏览器：<code>webkit</code>内核</li><li><code>Opera</code>浏览器：最初是自己的<code>presto</code>内核，后来加入谷歌，从<code>webkit</code>到<code>blink</code>内核</li></ol><p>移动端浏览器内核，主要是指系统内置浏览器的内核。</p><p>360，猎豹浏览器：<code>IE+Chrome</code>双内核</p><p>搜狗，遨游，QQ浏览器：<code>trident</code>（兼容模式）+ <code>webkit</code>（高速模式）</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM浏览器对象模型</title>
      <link href="/2019/11/24/BOM/"/>
      <url>/2019/11/24/BOM/</url>
      
        <content type="html"><![CDATA[<p>BOM是浏览器厂商在各自浏览器上定义的，兼容性较差，缺乏标准；组成：DOM, location, navigation, screen, history;</p><p><code>window</code>对象是浏览器的顶级对象；定义在全局作用域中的变量、函数都会成为<code>window</code>对象的属性和方法；注：<code>window.name</code>返回值为空字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面加载事件</span></span><br><span class="line">方式一：</span><br><span class="line"><span class="comment">// 当文档内容完全加载完成会触发该事件（包括图像、css、脚本文件等）</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;<span class="comment">// 只能写一次，如果有多个会以最后一个为准</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line"><span class="comment">// 仅当DOM加载完成就触发该事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul><li><p><code>setTimeout()</code></p></li><li><p><code>setInterval()</code></p></li><li><p>停止定时器：<code>window.clearTimeout(timeoutID)  /  clearInterval()</code></p></li></ul><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a><code>location对象</code></h3><p><code>window</code>对象提供了一个<code>location</code>属性，用于获取或设置窗体的<code>url</code>，并且可对其进行解析，该属性返回的是一个对象，所以该属性也称为<code>location</code>对象</p><table><thead><tr><th>location对象属性</th><th>返回值</th></tr></thead><tbody><tr><td><code>location.href</code></td><td>URL</td></tr><tr><td><code>location.host</code></td><td>返回主机（域名）</td></tr><tr><td><code>location.port</code></td><td>返回端口号，如果未写则返回空字符串</td></tr><tr><td><code>location.pathname</code></td><td>路径</td></tr><tr><td><code>location.search</code></td><td>参数</td></tr><tr><td><code>location.hash</code></td><td>返回片段  #后面的内容  常见于连接锚点</td></tr></tbody></table><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a><code>navigator对象</code></h3><p>包含有关浏览器的信息，常用的属性<code>userAgent</code>: 用于返回由客户机发送服务器的<code>user-agent</code>头部的值</p><p>查询用户打开页面的终端，实现不同跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>)) &#123;</span><br><span class="line">  <span class="built_in">window</span>.location.href = <span class="string">''</span>;            <span class="comment">// 手机</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.location.href = <span class="string">''</span>;            <span class="comment">// 电脑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元素偏移offset"><a href="#元素偏移offset" class="headerlink" title="元素偏移offset"></a>元素偏移offset</h3><table><thead><tr><th><code>element.offsetParent</code></th><th>返回作为该元素带有==定位的父级元素===，如果父级都没有定位则返回body</th></tr></thead><tbody><tr><td><code>offsetTop/Left</code></td><td>元素相对于带有定位的父元素上/左边框的偏移</td></tr><tr><td><code>element.offsetWidth/Height</code></td><td>返回包括padding, 边框和内容区域的宽度，==没有单位==</td></tr></tbody></table><p>注 ：<code>offset</code>可以得到任意样式表中的样式值，返回值没有单位，<code>padding+border+width</code>，是只读属性;</p><p><code>style</code>只能得到行内样式表中的样式值，返回值是带有单位的字符串，仅是内容的宽度，是可读可写属性</p><p><img src="/2019/11/24/BOM/offset.png" alt="offset"></p><h3 id="元素可视区client"><a href="#元素可视区client" class="headerlink" title="元素可视区client"></a>元素可视区client</h3><table><thead><tr><th><code>element.clientTop/ clientLeft</code></th><th>返回元素上，左边框的大小</th></tr></thead><tbody><tr><td><code>element.clientWidth / clientHeight</code></td><td>返回包括padding，内容的宽度，不含边框，返回值没有单位</td></tr></tbody></table><h3 id="元素滚动scroll"><a href="#元素滚动scroll" class="headerlink" title="元素滚动scroll"></a>元素滚动scroll</h3><p>如果浏览器的宽高不足以显示整个页面时，会出现滚动条；当滚动条向下滚动时，页面上面被隐藏的高度，称为被页面卷去的头部；滚动条在滚动时会触发<code>onscroll</code>事件。</p><table><thead><tr><th>scroll属性</th><th>作用</th></tr></thead><tbody><tr><td><code>element.scrollTop/scrollLeft</code></td><td>返回被卷去的上、左侧距离，不带单位</td></tr><tr><td><code>element.scrollWidth/scrollHeight</code></td><td>返回自身实际宽高不含边框，没有单位</td></tr></tbody></table><h4 id="页面被卷去的头部兼容性解决方案"><a href="#页面被卷去的头部兼容性解决方案" class="headerlink" title="页面被卷去的头部兼容性解决方案"></a>页面被卷去的头部兼容性解决方案</h4><ol><li><p>声明了DTD(文档类型定义)，使用<code>document.documentElement.scrollTop</code></p></li><li><p>未声明DTD，使用<code>document.body.scrollTop</code></p></li><li><p><code>window.pageYOffset/window.pageXOffset</code>  —-ie9+</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">    left: <span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="number">0</span>,</span><br><span class="line">    top: <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop || <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web API</title>
      <link href="/2019/11/24/web%20API/"/>
      <url>/2019/11/24/web%20API/</url>
      
        <content type="html"><![CDATA[<p><code>web API</code>：浏览器提供的一套操作浏览器功能和页面元素的API（BOM DOM);</p><p><code>DOM(document object model)</code>:文档对象模型，w3c组织推荐的处理可扩展标记语言的标准编程接口；</p><p>事件：触发–响应机制；事件三要素：事件源，事件类型和事件处理程序；</p><table><thead><tr><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr><td><code>onclick</code></td><td>鼠标点击左键</td></tr><tr><td><code>onmouseover</code></td><td>鼠标经过</td></tr><tr><td><code>onmouseout</code></td><td>鼠标离开</td></tr><tr><td><code>onfocus</code></td><td>获得鼠标焦点</td></tr><tr><td><code>onblur</code></td><td>失去鼠标焦点</td></tr><tr><td><code>onmousemove</code></td><td>鼠标移动</td></tr><tr><td><code>onmouseup</code></td><td>鼠标弹起</td></tr><tr><td><code>onmousedown</code></td><td>鼠标按下</td></tr></tbody></table><h4 id="获取属性值"><a href="#获取属性值" class="headerlink" title="获取属性值"></a>获取属性值</h4><ul><li><p><code>element.属性</code>：获取元素内置属性值（元素本身自带的属性）</p></li><li><p><code>element.getAttribute(&#39;属性&#39;)</code>：主要用于获取自定义属性；自定义属性是为了保存并使用数据，有些数据可以保存到页面中而不用保存到数据库中；为了避免歧义==<code>H5</code>规定自定义属性以<code>data-</code>开头==</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h5新增获取自定义属性，存在兼容性问题</span><br><span class="line">element.dataset.index;  // dataset是一个存放所有以data开头的自定属性的集合</span><br><span class="line">或 element.dataset['index']</span><br></pre></td></tr></table></figure></li></ul><h4 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h4><ul><li><code>element.属性=值</code></li><li><code>element.setAttribute(&#39;属性&#39;, &#39;值&#39;)</code>：主要用于设置自定义属性</li></ul><h4 id="移除属性"><a href="#移除属性" class="headerlink" title="移除属性"></a>移除属性</h4><p><code>element.removeAttribute(&#39;属性&#39;)</code></p><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><p>网页中的所有内容都是节点，（标签、属性、文本、注释等），在<code>DOM</code>中用<code>node</code>表示；</p><p>一般节点至少拥有三个基本属性：<code>nodeType, nodeName, nodeValue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeType: 1 元素节点</span><br><span class="line">          2 属性节点</span><br><span class="line">          3 文本节点（包含文字、空格、换行等）</span><br></pre></td></tr></table></figure><ul><li><p><code>node.parentNode</code>:返回节点的最近的一个父节点，如果指定的节点没有父节点则返回null；</p></li><li><p><code>parentNode.childNodes</code>:返回指定节点所有子节点，及时更新，包括元素节点、文本节点，一般很少使用；</p></li><li><p><code>parentNode.children</code>:只读属性，返回所有的==子元素==节点，非标准但所有浏览器都支持推荐使用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">firstChild, lastChild包含其他节点，firstElementChild, lastElementChild有兼容性问题，ie9以上才支持，通常采取以下做法：</span><br><span class="line">parentNode.children[0]        // 获取第一个子元素节点</span><br><span class="line">parentNode.children[parentNode.children.length-1]</span><br><span class="line"></span><br><span class="line">nextSibling: 下一个兄弟节点   --previousSibling (有兼容性问题)</span><br><span class="line">nextElementSibling: 下一个兄弟元素节点    --previousElementSibling</span><br></pre></td></tr></table></figure><p><code>document.createElement(&#39;tagName&#39;)</code>:动态创建元素节点</p><p><code>node.appendChildren(child)</code>方法，将节点添加到指定父节点的末尾</p><p><code>node.insertBefor(child, 指定元素)</code>：将一个子节点添加到父节点的指定子节点前面；</p><p><code>node.removeChild()</code>：从<code>node</code>节点中删除一个子节点，返回删除的节点，</p><p>==阻止连接跳转，链接改为：<code>javascript:void(0); / javascript:;</code>==</p><p><code>node.cloneNode()</code>: 返回调用该方法的节点的一个副本；注：如果括号中的参数为空或为<code>false</code>，则是浅拷贝，即只复制节点本身，而不复制里面的子节点；如果参数为<code>true</code>，则为深拷贝，会复制节点本身以及里面的左右子节点。</p><h3 id="创建元素三种方式的区别"><a href="#创建元素三种方式的区别" class="headerlink" title="创建元素三种方式的区别"></a>创建元素三种方式的区别</h3><ul><li><code>document.write</code>: 直接将内容写入页面的内容流，如果页面文档流加载完毕再调用这句话则会导致页面重绘</li><li><code>document.innerHTML</code>: 将内容写入<code>DOM</code>节点，创建多个元素（数组方式非拼接方式）效率高</li><li><code>document.createElement()</code>: 效率稍低但结构清晰</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><code>eventTarget.addEventListener(type, listener[, useCapture])</code>: ie9+支持；<code>type</code>:事件类型字符串；<code>listener</code>:事件处理函数，事件发生时调用；<code>useCapture</code>: 布尔值，默认为false，表示事件在冒泡阶段调用事件处理程序；<code>true</code>表示在事件捕获阶段调用事件处理程序；</p><p><code>eventTarget.attacheEvent(eventNameWithOn, callback)</code>: (ie8-), 将制定的监听器注册到目标对象上，当该对象触发指定的事件时，指定的回调函数就会被执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件监听兼容性解决方案， 了解</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEventListener</span>(<span class="params">element, eventName, fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(element.addEventListener) &#123;</span><br><span class="line">element.addEventListener(eventName, fn);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    element.attachEvent(<span class="string">'on'</span> + eventName, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">'on'</span>+eventName] = fn;   <span class="comment">// 类似elememt.onclick = fn</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEventListener</span>(<span class="params">element, eventName, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">    element.removeEventListener(eventName, fn);  </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">    element.detachEvent(<span class="string">'on'</span>+eventName, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">'on'</span>+eventName] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解绑事件（删除事件）</strong></p><ul><li><code>eventTarget.onclick = null;</code></li><li><code>eventTarget.removeEventListener(type, listener[, userCapture])</code>;</li><li><code>eventTarget.detachEvent(eventNameWithOn, callback)</code>;</li></ul><p><code>DOM</code>事件流：事件发生时在元素节点之间按照特定的顺序传播的过程；事件流会经历三个阶段：捕获阶段、当前目标阶段、冒泡阶段；</p><p>注：<code>js</code>代码只能执行捕获或冒泡中的一个阶段;<code>onblur, onfocus, onmouseenter, onmouseleave</code>事件是没有冒泡的</p><p>事件发生后，与事件相关的一系列信息数据的集合都放到==事件对象==中；事件触发时就会产生事件对象，并且系统会以实参的形式传递给事件处理函数，所以在事件处理函数中声明一个形参用来接收事件对象；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件对象兼容性处理</span></span><br><span class="line"><span class="comment">// IE8-，浏览器不会给方法传递参数</span></span><br><span class="line"></span><br><span class="line">e = e || <span class="built_in">window</span>.event;</span><br></pre></td></tr></table></figure><table><thead><tr><th>事件对象属性方法</th><th>说明</th></tr></thead><tbody><tr><td><code>e.target</code></td><td>返回触发事件的对象</td></tr><tr><td><code>e.srcElement</code></td><td>返回触发事件的对象（IE678）</td></tr><tr><td><code>e.type</code></td><td>返回事件类型，没有on</td></tr><tr><td><code>e.stopPropagation()</code></td><td>阻止冒泡</td></tr><tr><td><code>e.cancelBubble</code></td><td>阻止冒泡（IE678）</td></tr><tr><td><code>e.preventDefault()</code></td><td>阻止事件默认行为（如连接跳转）</td></tr><tr><td><code>e.returnValue</code></td><td>阻止事件默认行为（IE678）</td></tr></tbody></table><p><code>e.target</code>是触发事件的具体元素，<code>this</code>是绑定事件的元素对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止事件冒泡的兼容性处理</span></span><br><span class="line"><span class="keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件委托也称为事件代理，<code>jQuery</code>中称为事件委派，即不给子元素注册事件，给父元素注册事件，把处理代码放在父元素的事件中执行；==给父元素注册事件，利用事件冒泡，当子元素触发时会冒泡到父元素，然后去控制相应的子元素==</p><table><thead><tr><th>鼠标事件对象</th><th>说明</th></tr></thead><tbody><tr><td><code>e.clientX / e.clientY</code></td><td>返回鼠标相对于浏览器窗口可视区的坐标</td></tr><tr><td><code>e.pageX / e.pageY</code></td><td>返回鼠标相对于文档页面的坐标（ie9+)</td></tr><tr><td><code>e.screenX / e.screenY</code></td><td>鼠标相对于电脑屏幕的坐标</td></tr></tbody></table><p>常用的键盘事件：<code>onkeydown, onkeypress(不能识别功能键)，onkeyup</code>；键盘事件对象属性：<code>keyCode</code>(注：<code>keydown,keyup不区分大小写</code>)</p><h3 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h3><p>缓动动画就是让元素运动速度有所变化</p><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>数据存储在用户浏览器中；设置、读取方便，甚至刷新页面不丢失数据；容量较大，<code>sessionStoragey-&gt;5M; localStorage-&gt;20M</code>;只能存储字符串，可以将对象<code>JSON.stringify()</code>编码后存储</p><h4 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a><code>window.sessionStorage</code></h4><p>生命周期为关闭浏览器窗口；在同一个窗口下数据可以共享；以键值对的形式进行数据存储使用；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据</span></span><br><span class="line">sessionStorage.setItem(key, value);</span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">sessionStorage.getItem(key);</span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">session.removeItem(key);</span><br><span class="line"><span class="comment">// 清空数据</span></span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="/2019/11/24/flex%E5%B8%83%E5%B1%80/"/>
      <url>/2019/11/24/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>当为父盒子设置<code>flex</code>布局（通过给父盒子添加<code>flex</code>属性，来控制子盒子的位置和排列方式）后，子元素的<code>float/clear/vertical-align</code>属性将失效；采用flex布局的元素称为容器，他的所有子元素自动称为容器成员，称为项目</p><p><code>flex</code>父项常见属性</p><ul><li><p><code>flex-direction</code>：设置主轴的方向,子元素跟着主轴来排列，默认值row，从左到右；row-reverse：从右向左；column：从上到下；column-reverse：从下到上</p></li><li><p><code>justify-content</code>: 设置主轴上的子元素排列方式</p><p>默认值从头部开始，如果x轴为主轴则从左到右：<code>flex-start</code>; <code>flex-end/center/space-around(平分剩余空间)/space-between（先两边贴边再平分剩余空间）</code></p></li><li><p><code>flex-wrap</code>：设置是否换行</p><p><code>nowrap</code>（默认，不换行）/ <code>wrap(换行)</code></p></li><li><p><code>align-content</code>：（多行）设置侧轴上子元素的排列方式</p><p><code>flex-start/flex-end/center/space-around/space-between/stretch</code></p></li><li><p><code>align-items</code>:(单行)控制子项在侧轴上的排列方式，在子项为单行时使用</p><p><code>flex-start/flex-end/center/stretch</code></p></li><li><p><code>flex-flow</code>：是<code>flex-direction和flex-wrap属性的复合属性</code></p><p><code>flex-flow: row wrap;</code></p></li></ul><p><code>flex</code>布局子项常见属性：</p><ul><li>flex：子项占有的份数</li><li><code>align-self</code>: 控制子项自己在侧轴的排列方式，允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>; 默认值<code>auto</code>继承自父元素，如果没有父元素则相当于<code>stretch</code></li><li><code>order</code>：定义子项的排列顺序</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli</title>
      <link href="/2019/11/23/vue-cli/"/>
      <url>/2019/11/23/vue-cli/</url>
      
        <content type="html"><![CDATA[<p>title: Vue-cli<br>date: 2019-11-23 16:58:17<br>categories: Vue<br>tags: [Vue, Vue-cli]</p><p>cli: command-line interface, 命令行界面，俗称脚手架</p><p><code>Vue cli2</code>初始化项目：<code>vue init webpack projectname</code></p><img src="/2019/11/23/vue-cli/media\vuecli2初始化.png" style="zoom:80%;"><p><code>runtime-compiler 和runtime-only的区别</code></p><img src="/2019/11/23/vue-cli/media\`runtime-compiler 和runtime-only的区别`.png" style="zoom:67%;"><p><code>vue</code>程序运行过程：</p><ul><li><code>runtime-compiler</code>: <code>template</code> -&gt; 转换成<code>ast</code> -&gt;<code>render</code>-&gt;<code>virtual dom</code> -&gt; <code>ui</code></li><li><code>runtime-only</code>: <code>render</code> -&gt; <code>virtual dom</code> -&gt; <code>ui</code>(1.性能更高 2.代码量更少)</li></ul><p><code>Vue cli3</code>初始化项目：<code>vue create projectname</code></p><img src="/2019/11/23/vue-cli/media\vuecli3初始化.png" style="zoom:80%;">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端模块化</title>
      <link href="/2019/11/23/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2019/11/23/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>常见的模块化规范：</p><ul><li><p><code>CommonJS</code>—node实现  , AMD, CMD, ES6(modules)</p></li><li><p><code>CommonJS</code>的导出/导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  flag: <span class="literal">true</span></span><br><span class="line">  test(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b               </span><br><span class="line">  &#125;,</span><br><span class="line">  test(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b               </span><br><span class="line">  &#125;                    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导入</span></span><br><span class="line"><span class="keyword">let</span> &#123;test, demo, flag&#125; = <span class="built_in">require</span>(<span class="string">'moduleA'</span>)</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">const</span> xxx = <span class="built_in">require</span>(<span class="string">'moduleA'</span>)</span><br><span class="line"><span class="keyword">let</span> test = xxx.test</span><br><span class="line"><span class="keyword">let</span> demo = xxx.demo</span><br><span class="line"><span class="keyword">let</span> flag = xxx.flag</span><br></pre></td></tr></table></figure><ul><li>export default 可以让导入者命名导入的模块中的功能，在同一个模块中只能存在一个</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-插槽</title>
      <link href="/2019/11/23/Vue-%E6%8F%92%E6%A7%BD/"/>
      <url>/2019/11/23/Vue-%E6%8F%92%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<p>组件的插槽是为了让我们封装的组件具有更强的扩展性，让使用者决定组件内部要展示的内容</p><h3 id="slot基本使用"><a href="#slot基本使用" class="headerlink" title="slot基本使用"></a>slot基本使用</h3><ul><li>通过<slot>元素就可以为子组件开启一个插槽，可以为其添加默认内容，父组件没有插入其他内容时显示</slot></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>=================================================<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>this is new.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is component of son.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>this is inital<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="actionscript">        template: <span class="string">'#a'</span>,</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2019/11/23/Vue-%E6%8F%92%E6%A7%BD/media\slot基本使用.png" alt="slot基本使用" style="zoom:60%;"><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><ul><li>一个插槽传入多个元素标签（作为统一的替换内容）</li><li>当组件的功能复杂时，组件的插槽可能有多个，为了区分就需要给<slot>增加一个name属性,使用时为标签元素指定slot属性值即可将元素放到对应的插槽位置。</slot></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>=================================================<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span> <span class="attr">slot</span>=<span class="string">"c"</span>&gt;</span>this is new.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">"b"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is component of son.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"c"</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>this is inital<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>父组件模板的所有东西都会放在父级作用域中编译；子组件模板的所有东西都会放在子级作用域内编译。</p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>父组件替换插槽的标签，但内容由子组件来提供</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1.列表形式展示 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"slotprops"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"info in slotprops.data"</span>&gt;</span>&#123;&#123; info &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 2.水平展示 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"slotprops"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"info in slotprops.data"</span>&gt;</span>&#123;&#123; info &#125;&#125;    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"mycpn"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">"planguages"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>=======================================<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  Vue.component(<span class="string">'my-cpn'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">    template: <span class="string">'#mycpn'</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        planguages: [<span class="string">'python'</span>, <span class="string">'c'</span>, <span class="string">'go'</span>, <span class="string">'node'</span>]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2019/11/23/Vue-%E6%8F%92%E6%A7%BD/media\作用域插槽.png" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> slot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-组件化开发</title>
      <link href="/2019/11/22/Vue-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>/2019/11/22/Vue-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h3><ul><li>组件是可复用的<code>Vue</code>实例，所以除<code>el</code>外与<code>new Vue</code>接收相同的选项（·<code>data, computed, watch, methods,</code>生命周期钩子等)；可以将组件进行任意次复用，每用一次组件都会有一个新的组件实例被创建，每个组件都会各自独立维护它的<code>count</code></li><li>组件是一个单独功能模块的封装，这个模块有属于自己的HTML模板，也有属于自己的数据data</li><li>==组件的data选项必须是一个函数==，因此每个实例可以维护一份被返回对象的独立的拷贝</li><li>通常一个应用会以一棵嵌套的组件树的形式来组织；</li></ul><img src="/2019/11/22/Vue-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/media\Vue组件的组织.png" alt="组件树" style="zoom:80%;"><ul><li>组件使用步骤：创建组件构造器、注册组件、使用组件；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 3.组件使用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">test1</span>&gt;</span><span class="tag">&lt;/<span class="name">test1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 1.创建组件构造器对象</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> constructor1 = Vue.extend(&#123;</span></span><br><span class="line">    template: `</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">      &lt;h3&gt;<span class="keyword">this</span> <span class="keyword">is</span> title.&lt;/h3&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="actionscript">  <span class="comment">// 2.注册组件</span></span></span><br><span class="line"><span class="actionscript">  Vue.component(<span class="string">'test1'</span>, constructor1)</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2019/11/22/Vue-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/media\组件使用运行结果.png" style="zoom:80%;"><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><ul><li><p>为了能在模板中使用，组件必须先注册以便Vue能够识别；注册类型：全局注册和局部注册；</p><p>全局注册的组件可以使用在任意<code>Vue</code>实例下使用；</p><p>如果注册的组件是挂载在某个实例中，则其为一个局部组件；</p>  <script>    // 1.创建组件构造器对象    const constructor1 = Vue.extend({      template: `      <div>        <h3>this is title.</h3>      </div>      `    })    // 2.注册组件（全局）    Vue.component('test1', constructor1)    const app = new Vue({      el: '#app',      data: {},      components: {         //2.- 注册局部组件 test2为组件标签名                                                          test2: constructor1                                                           }    })  </script></li><li><p><code>Vue.extend</code>：调用<code>Vue.extend()</code>创建的是一个组件构造器，通常传入<code>template</code>代表自定义组件的模板</p></li><li><p><code>Vue.component()</code>:将组件构造器注册为一个组件，并给它取一个标签名，传入两个参数：参数一：注册组件的标签名，参数二：组件构造器</p></li><li><p>组件必须挂载在某个Vue实例下才会生效</p></li><li><p>注册组件语法糖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.全局组件 </span></span><br><span class="line">Vue.component(<span class="string">'constructor1'</span>, &#123;</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string"> &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h3&gt;this is title.&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2.局部组件</span></span><br><span class="line"> <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,</span><br><span class="line">      components: &#123;   <span class="comment">//注册父组件</span></span><br><span class="line">        <span class="string">'test1'</span>: &#123;</span><br><span class="line"><span class="string">`&lt;h3&gt;this is title.&lt;/h3&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line">      &#125; </span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="父组件和子组件"><a href="#父组件和子组件" class="headerlink" title="父组件和子组件"></a>父组件和子组件</h3><p>组件之间存在层级关系，父子组件是其中一种</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 3.组件使用 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">test1</span>&gt;</span><span class="tag">&lt;/<span class="name">test1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">   <span class="comment">// 1.创建组件构造器对象</span></span></span><br><span class="line"><span class="actionscript">   <span class="keyword">const</span> constructor1 = Vue.extend(&#123;</span></span><br><span class="line">     template: `</span><br><span class="line"><span class="handlebars"><span class="xml">     <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">       &lt;h3&gt;<span class="keyword">this</span> <span class="keyword">is</span> title.&lt;/h3&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">     `</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="actionscript">   <span class="keyword">const</span> constructor2 = Vue.extend(&#123;</span></span><br><span class="line">     template: `</span><br><span class="line"><span class="handlebars"><span class="xml">       <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">         &lt;h3&gt;<span class="keyword">this</span> <span class="keyword">is</span> parent&lt;/h3&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">         <span class="tag">&lt;<span class="name">child1</span>&gt;</span><span class="tag">&lt;/<span class="name">child1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">     `,</span><br><span class="line"><span class="actionscript">     components: &#123; <span class="comment">//&lt;child1&gt;会被浏览器忽略，其只能在父组件中被识别</span></span></span><br><span class="line"><span class="actionscript">       <span class="string">'child1'</span>: constructor1</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="actionscript">   <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">     el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="actionscript">     components: &#123;   <span class="comment">//注册父组件</span></span></span><br><span class="line"><span class="actionscript">       <span class="string">'test1'</span>: constructor2</span></span><br><span class="line">     &#125; </span><br><span class="line">   &#125;)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件抽离写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"cnp1"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//模板内容</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">        &lt;h3&gt;<span class="keyword">this</span> <span class="keyword">is</span> title.&lt;/h3&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">方式二：</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cnp2"</span>&gt;</span></span><br><span class="line">    //模板内容</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>this is title.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">Vue.component('constructor1', &#123;</span><br><span class="line">template: '#cnp1'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h4><p>在开发中往往从服务器请求很多数据，需要从上层传递到下层；</p><p>方式一：通过props向子组件传递数据</p><ul><li><p><code>prop</code>是可以在组件上注册的自定义特性，当一个值传递给<code>prop</code>特性时，它就变为组件实例的一个属性</p></li><li><p><code>props</code>属性声明需要从父组件接收到的数据</p></li><li><p><code>props</code>的值有两种方式：字符串数组，数组中的字符串就是传递时的名称；对象，可以设置传递时的名称和值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span> <span class="attr">:abc</span>=<span class="string">"movies"</span> <span class="attr">:cmessage</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cpn"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>this is a component.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; cmessage &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in abc"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> cpn1 = &#123;</span></span><br><span class="line"><span class="actionscript">    template: <span class="string">'#cpn'</span>,</span></span><br><span class="line"><span class="actionscript">    props: [<span class="string">"abc"</span>, <span class="string">"cmessage"</span>]</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="actionscript">      message: <span class="string">"this is content in vue"</span>,</span></span><br><span class="line"><span class="actionscript">      movies: [<span class="string">'film1'</span>, <span class="string">'film2'</span>, <span class="string">'film3'</span>]</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2019/11/22/Vue-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/media\prop-数组.png" style="zoom:50%;"></li><li><p>当需要对<code>props</code>进行类型等验证时就需要对象写法，验证支持的数据类型：<code>String, Number, Boolean, Array, Object, Date, Function, Symbol</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  <span class="comment">//1.类型限制</span></span><br><span class="line">abc: <span class="built_in">Array</span>,</span><br><span class="line">cmessage: <span class="built_in">String</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.提供一些默认值</span></span><br><span class="line">  cmessage1: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'this is content....'</span>,    <span class="comment">//在没有传值时才会显示默认值</span></span><br><span class="line">    required: <span class="literal">true</span>  <span class="comment">//表明cmessage必须传值</span></span><br><span class="line">  &#125;                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：如果<code>props</code>变量用驼峰命名，在使用时必须改为连字符形式</p><p>方式二：通过事件（自定义事件<code>$emit</code>）向父组件发送消息</p><p><code>Vue</code>的子组件用<code>$emit()</code>来触发事件，父组件用$on()来监听子组件的事件，父组件也可以直接在子组件的自定义标签上使用<code>v-on</code>来监听子组件触发的自定义事件</p><p>子组件内部通过==this.$emit(‘方法名’，要传递的数据)==方式，来调用父组件中的方法，同时把数据传递给父组件使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is parent.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>===========================================<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span> @<span class="attr">increment</span>=<span class="string">"incretotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cpn"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is son.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increase"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"decrease"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  Vue.component(<span class="string">'my-cpn'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">    template: <span class="string">'#cpn'</span>,</span></span><br><span class="line"><span class="actionscript">    data: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        count: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      increase() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.count++;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>, <span class="number">1</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line">      decrease() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.count--;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>, <span class="number">2</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      total: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="actionscript">      incretotal: <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> </span>&#123;</span></span><br><span class="line">        if (val == 1) &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.total += <span class="number">1</span>;</span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (<span class="keyword">this</span>.total &lt;= <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.total = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.total -= <span class="number">1</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="父子组件的访问方式"><a href="#父子组件的访问方式" class="headerlink" title="父子组件的访问方式"></a>父子组件的访问方式</h4><ul><li><p>父组件访问子组件：<code>$children</code> 或 <code>$refs</code></p><p><code>this.$children</code> 是一个数组类型，包含所有子组件对象</p></li><li><p>子组件访问父组件：<code>$parent</code></p></li><li><p><code>this.$root</code>访问根组件，即<code>Vue</code>实例</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础（二）</title>
      <link href="/2019/11/21/Vue%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/11/21/Vue%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a><code>v-for</code></h4><ol><li><p>遍历数组</p><p>支持可选的第二个参数为当前项的索引</p></li><li><p>遍历对象</p><p>只有一个参数时获取的为<code>value</code>, 也可以提供第二个参数为键名，参数三为索引</p><p><code>v-for=&quot;(value, key, index) in object&quot;</code></p></li><li><p><code>key</code></p><p><code>v-for</code>更新已经渲染过的元素列表时，默认用‘就地复用’策略；如果数据项的顺序被改变，<code>Vue</code>不会移动<code>DOM</code>元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已经被渲染过的每个元素；</p><p>在对应的元素上添加<code>key</code>属性，可以高效的更新虚拟<code>DOM</code></p></li></ol><h4 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h4><ul><li>因为<code>Vue</code>是响应式的，所以数据发生变化时，<code>Vue</code>会自动检测数据变化，视图会发生对应的更新</li><li><code>Vue</code>中观察数组的变异方法（会改变原始数组） <code>push pop shift unshift splice sort reverse</code></li><li>Vue内部提供的修改数组的方法set <code>Vue.set(要修改的对象，索引值，修改后的值)</code></li><li>非变异方法：不会改变原始数组，但会返回一个新数组 <code>filter concat slice</code></li><li>注：Vue不能检测以下变动的数组：<ul><li>利用索引来设置一个项时</li><li>修改数组的长度时</li></ul></li></ul><h3 id="表单输入绑定v-model"><a href="#表单输入绑定v-model" class="headerlink" title="表单输入绑定v-model"></a>表单输入绑定<code>v-model</code></h3><ul><li><p><code>v-model</code>指令可以用在表单元素<code>&lt;input&gt; &lt;textarea&gt; &lt;select&gt;</code>上创建双向数据绑定，它会根据控件类型自动选取正确方法来更新元素，（注：会忽略所有表单元素的value, checked, selected特性的初始值，将Vue实例的数据作为数据来源）</p></li><li><p><code>v-model</code>其实是语法糖，本质上是包含两个操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">相当于</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-bind:value</span>=<span class="string">"message"</span> <span class="attr">v-on:input</span>=<span class="string">"message = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-model  -- checkbox</code></p><p>单个复选框时，<code>v-model</code>为布尔值，此时<code>input</code>的<code>value</code>并不影响<code>v-model</code>的值；</p><img src="/2019/11/21/Vue%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/media\v-model-checkbox1.png" alt="v-model:单个复选框" style="zoom:80%;"><p>多个复选框时，可以选中多个，所以对应<code>data</code>中属性是一个数组，当选中时就会将相应的<code>input</code>中的<code>value</code>添加到数组中；</p></li><li><p><code>v-model --select</code></p><p>单选时，<code>v-model</code>绑定的是一个值，会将对应的value赋值到绑定对象中</p><p>多选时，<code>v-mode</code>l绑定的是一个数组，选中多个值时会将选中的<code>option</code>对应的<code>value</code>添加到绑定的数组中</p><img src="/2019/11/21/Vue%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/media\v-model-select.png" style="zoom:80%;"></li><li><p>修饰符</p><ul><li><code>.lazy</code>让数据在失去焦点或回车时才会进行更新</li><li><code>.number</code>默认输入框都会被当做字符串处理，让输入框的内容自动转换为数字类型</li><li><code>.trim</code>：去除输入数据两端的空格</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/2019/11/20/ES6-let-const/"/>
      <url>/2019/11/20/ES6-let-const/</url>
      
        <content type="html"><![CDATA[<p>函数是一个作用域</p><p><code>const</code>声明不允许修改绑定，但是可以修改绑定的值；即用const声明对象时，可以修改对象中的值；</p><p>箭头函数中的this：向外层作用域中依次查找直至找到this</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exec-match-test等使用正则表达式的区别</title>
      <link href="/2019/11/20/exec-match-test%E7%AD%89%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/20/exec-match-test%E7%AD%89%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>exec</td><td>一个在字符串中执行查找匹配的RegExp方法，返回查找结果的第一个值（数组），未匹配到则返回null</td></tr><tr><td>test</td><td>一个在字符串中测试是否匹配的RegExp方法，返回true或false</td></tr><tr><td>match</td><td>在字符串中执行查找匹配的String方法，返回一个数组或null</td></tr><tr><td>search</td><td>在字符串中测试匹配的String方法，返回匹配到的位置索引，失败返回-1</td></tr><tr><td>replace</td><td>在字符串中执行查找匹配的String方法，使用替换字符串换掉匹配的子字符串</td></tr><tr><td>split</td><td>String方法，使用正则表达式或固定字符串分割一个字符串，并将分割后的子字符串存储到数组中</td></tr></tbody></table><h3 id="exec方法"><a href="#exec方法" class="headerlink" title="exec方法"></a>exec方法</h3><p><code>re.exec(str)</code>: </p><p>​    <code>re:</code> 正则表达式对象； <code>str：</code>要在其中执行查找的String对象或字符串文字</p><p>​     ==默认只返回匹配结果的第一个值==，如果设置了全局标记则从上次匹配结束的位置开始查找</p><p>注：在匹配后，<code>re</code>的l<code>astIndex</code>属性被设置为匹配文本的最后一个字符的下一个位置；<code>lastIndex</code>并不在返回对象的属性中，而是正则表达式对象的属性</p><h3 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h3><p><code>string.match(re)</code>: 如果没有全局匹配标志则只执行一次匹配，返回一个数组，该数组的第0个元素为匹配文本，其余元素存放的是与正则表达式的子表达式匹配的文本；返回的数组含有两个对象属性 input（对查找字符串的引用）， index(匹配文本在查找字符串中的位置)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MatchDemo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r, re; </span><br><span class="line">  <span class="keyword">var</span> s = <span class="string">"The rain in Spain falls mainly in the plain"</span>;</span><br><span class="line">  <span class="comment">// 创建正则表达式模式。</span></span><br><span class="line">  re = <span class="regexp">/(a)in/ig</span>; </span><br><span class="line">  r = s.match(re); </span><br><span class="line">  <span class="comment">// 返回的数组包含了所有 "ain" 出现的四个匹配，r[0]、r[1]、r[2]、r[3]。没有子匹配项</span></span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;</span><br><span class="line">MatchDemo()   <span class="comment">//[ 'ain', 'ain', 'ain', 'ain' ]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MatchDemo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r, re; </span><br><span class="line">  <span class="keyword">var</span> s = <span class="string">"The rain in Spain falls mainly in the plain"</span>;</span><br><span class="line">  re = <span class="regexp">/(a)in/i</span>; 。</span><br><span class="line">  r = s.match(re); </span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">  <span class="built_in">console</span>.log(r.index)          <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">console</span>.log(r.input)          <span class="comment">// The rain in Spain falls mainly in the plain</span></span><br><span class="line">&#125;</span><br><span class="line">MatchDemo()</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">[ <span class="string">'ain'</span>,</span><br><span class="line">  <span class="string">'a'</span>,</span><br><span class="line">  index: <span class="number">5</span>,</span><br><span class="line">  input: <span class="string">'The rain in Spain falls mainly in the plain'</span>,</span><br><span class="line">  groups: <span class="literal">undefined</span> ]</span><br></pre></td></tr></table></figure><h3 id="test方法"><a href="#test方法" class="headerlink" title="test方法"></a>test方法</h3><p><code>re.test(str)</code>: 用于检测一个字符串是否匹配某个模式，返回一个布尔值</p><p>等价形式： <code>(re.exec(str) != null)</code></p><p>注：==<code>test</code>继承正则表达式的<code>lastIndex</code>属性，在全局匹配时注意==</p><h3 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h3><p><code>str.search(re)</code>:总是返回被查找字符串中与re匹配的子串的起始位置，如果没有找到则返回-1</p><p>注：会忽略g，不会执行全局匹配，同时总是忽略<code>re</code>的<code>lastIndex</code>属性，总是从字符串的开始进行检索</p><h3 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace 方法"></a>replace 方法</h3><p><code>str.replace(substr/re, replacement)</code>: 在字符串中用一个字符串替换另一个字符串，或者替换一个与正则表达式匹配的子串;返回一个完成了指定替换的<code>str</code>对象的复制; 默认只替换一个，全部替换需要全局表示 g</p><p><code>replacement</code>可以是字符串或函数</p><h3 id="split方法"><a href="#split方法" class="headerlink" title="split方法"></a>split方法</h3><p><code>str.split(seperator,[int])</code>: 将一个字符串分割成字符串数组，不包含分隔符本身</p><p>相反操作： <code>array.join()</code></p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础（一）</title>
      <link href="/2019/11/20/vue%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/11/20/vue%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ol><li><p><code>v-on</code>监听DOM事件，语法糖： @</p></li><li><p><code>mustache</code>语法，即用双大括号，内部可以直接写变量名或表达式；数据是响应式的，若希望元素或组件只渲染一次，即页面不会随着数据的改变而改变，可以使用指令==v-once==</p><p><code>&lt;p v-once&gt;&lt;/p&gt;</code></p><p>注：<code>v-once</code>就是一个简单的指令后面不需要任何表达式</p></li><li><p><code>mustache</code>语法会将数据解析为普通文本，有时需要输出真正的HTML，则需要使用<code>v-html</code>指令，该指令后通常会接一个<code>string</code>；<code>v-html</code>会将string中的内容解析出来并进行渲染</p></li><li><p>==<code>v-text</code>==接收一个<code>string</code>类型，用于将数据显示在截面中，但是==会覆盖标签中原有的内容==；使用<code>mustache</code>语法比较多，不会覆盖标签中原有内容，可以实现字符串的拼接;</p></li><li><p><code>v-pre</code>：用于跳过该元素及其子元素的编译过程，直接显示原有的<code>mustache</code>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=<span class="string">"app"</span>&gt; </span><br><span class="line">   &lt;p&gt;&#123;&#123; rawHtml &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">   &lt;p v-html="rawHtml"&gt;&#123;&#123; rawHtml &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;h1 &gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;h1 v-text="message"&gt;&lt;/</span>h1&gt;</span><br><span class="line">&lt;h1 v-pre&gt;&#123;&#123; message &#125;&#125; <span class="keyword">this</span> is init.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>div&gt;</span><br><span class="line"> &lt;script src=<span class="string">"./vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="keyword">const</span> obj = &#123;</span><br><span class="line">     message: <span class="string">'this is content.'</span>,</span><br><span class="line">     rawHtml: <span class="string">'&lt;span style="color: red"&gt;this should be red.&lt;/span&gt;'</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">     el: <span class="string">'#app'</span>,</span><br><span class="line">     data: obj,</span><br><span class="line">     methods: &#123; &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol><img src="/2019/11/20/vue%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/v-html,v-text,v-pre.png" alt="v-html,v-text,v-pre" style="zoom:50%;"><ol start="5"><li><p>有时浏览器会直接显示未编译的<code>mustache</code>标签,</p><p><code>v-cloak</code> 指令，保持在元素上直到关联实例结束编译；通常会和<code>css</code>规则一起使用，以实现未编译的<code>mustache</code>标签隐藏，直到实例准备完毕；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    <span class="comment">/* 中括号[]:表属性选择器 */</span></span><br><span class="line">    [v-cloak] &#123; </span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;h3  v-cloak&gt;hello &#123;&#123; name &#125;&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">  &lt;script src=<span class="string">"./vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">          name: <span class="string">'lucky'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><ol><li><code>v-bind</code>用于绑定一个或多个属性值，或者向另一个组件传递<code>prop</code>值，语法糖： <code>:</code></li></ol><h4 id="绑定class"><a href="#绑定class" class="headerlink" title="绑定class"></a>绑定<code>class</code></h4><ul><li><p>两种方式：对象语法 和 数组语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, bold1: isBold &#125;"</span>&gt; <span class="keyword">this</span> is content.&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-bind:class="&#123; 类名1：布尔值，类名2：布尔值，...&#125;"&gt; this is content.&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>对象语法：<code>class</code>后面跟的是一个对象，通过相应的布尔值确定是否具有该类，可以和普通的类同时存在（取并集），如果过于复杂可以放在一个<code>methods</code>或<code>computed</code>中</p><p>数组语法：<code>class</code>后面跟的是一个数组，可以和普通类共存</p></li></ul><h4 id="绑定style"><a href="#绑定style" class="headerlink" title="绑定style"></a>绑定<code>style</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 :sylte=<span class="string">"&#123;fontSize: '50px'&#125;"</span>&gt;<span class="keyword">this</span> is title.&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">&lt;h3 :sylte="&#123;属性名: '属性值'&#125;"&gt;this is title.&lt;/</span>h3&gt;</span><br></pre></td></tr></table></figure><h3 :sylte="{fontSize: '50px'}">this is title.</h3>注：属性名可以用连字符或驼峰命名法；属性值必须用引号包裹，否则会被当做变量解析，也可以直接使用变量<p></p><h3 id="使用javascript表达式"><a href="#使用javascript表达式" class="headerlink" title="使用javascript表达式"></a>使用<code>javascript</code>表达式</h3><p>这些表达式会在所属的<code>Vue</code>实例的主句作用域下座位<code>javascript</code>被解析，每个绑定只能包含单个表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? 'yes' : 'no'&#125;&#125;</span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"'list-' + id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ul><li>计算属性写在实例的<code>computed</code>选项中，是一个函数，使用时直接当做属性而非函数调用（因为默认调用其get方法）</li><li>每个计算属性都包含一个 getter 和 setter</li></ul><h4 id="computed-和-methods-的区别"><a href="#computed-和-methods-的区别" class="headerlink" title="computed 和 methods 的区别"></a><code>computed</code> 和 <code>methods</code> 的区别</h4><ul><li>==计算属性基于依赖关系进行缓存==，如果多次使用时，计算属性只会调用一次，性能更高；只有相关依赖发生改变时才会重新求值</li><li><code>methods</code>中的方法每次调用都会重新执行</li></ul><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul><li><code>v-on</code>监听事件</li><li>可以接收一个需要调用的方法名称，如果该方法不需要额外的参数，那么后面的（）可以省略；如果方法本身需要参数，省略时默认将原生事件event参数传入；如果传入的实参不是基本类型为一个变量在实例中没有声明则为<code>undefined</code></li><li>如果同时需要传递某个参数和event时，可以通过<code>$event</code>传入事件</li><li>若函数需要多个参数，省略小括号，则默认将原生事件赋值给第一个参数，其他参数为<code>undefined</code>；实参个数小于实参个数时，没有对应实参的值为undefined</li></ul><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>以 . 开头：<code>.stop, .prevent, .capture, .self, .once, .passive</code></p><p><code>.stop</code>-调用<code>event.stopPropagation()</code> 阻止事件冒泡；</p><p><code>.prevent</code>-调用<code>event.preventDefault()</code> 阻止事件的默认行为；</p><p><code>.capture</code>使用捕获模式，即元素自身触发的事件先在此处理，然后才交由内部元素处理</p><p><code>.self</code>只有当<code>event.target</code>是当前元素自身时触发事件；</p><p><code>=.once</code>事件只会触发一次，<em>能被用到自定义的组件事件上</em>==（其他修饰符只能对原生的DOM事件起作用）==；</p><p><code>.passive</code>会告诉浏览器你不想阻止事件的默认行为，和<code>.prevent</code>一起使用时，<code>.prevent</code>将会被忽略</p><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p><code>&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</code></p><p>只有在<code>keyCode</code>=13时，调用<code>vm.submit()</code></p><p>可以使用按键别名<code>.enter, .tab, .delete（捕获删除和退格键）, .esc, .space, .up, .down, .left, .right</code>;</p><p>也可以通过全局<code>config.keyCodes</code>对象自定义按键修饰符别名</p><p><code>Vue.config.keyCodes.f1 = 112</code> 然后就可以使用 <code>v-on:keyup.f1</code></p><h4 id="鼠标按钮修饰符："><a href="#鼠标按钮修饰符：" class="headerlink" title="鼠标按钮修饰符："></a>鼠标按钮修饰符：</h4><p><code>.left, .right, .middle</code></p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h5><ul><li><code>v-if</code> 可以根据表达式的值在DOM中，生成或移除一个元素；如果需要切换多个元素可以将<code>&lt;template&gt;</code>元素当做包裹元素，并在其上使用<code>v-if</code>，最终的渲染结果不包含<code>&lt;template&gt;</code>元素</li><li><code>v-else</code>指令表示<code>v-if</code>的<code>else</code>块，必须紧跟在 <code>v-if</code>或<code>v-else-if</code>的元素后面，否则将不会被识别 </li></ul><h5 id="案例：点击切换登录方式"><a href="#案例：点击切换登录方式" class="headerlink" title="案例：点击切换登录方式"></a>案例：点击切换登录方式</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"flag"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">placeholder</span>=<span class="string">"please input your name"</span> <span class="attr">key</span>=<span class="string">"user-input"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"email"</span>&gt;</span>email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"email"</span> <span class="attr">placeholder</span>=<span class="string">"please input your email"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handletog"</span>&gt;</span>toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="actionscript">      flag: <span class="literal">true</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">     handletog() &#123;</span><br><span class="line"><span class="actionscript">       <span class="keyword">return</span> <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>存在的问题：如果在文本框有输入的情况下切换，文字依然会被保留</li><li>原因：<code>Vue</code>在进行<code>DOM</code>渲染时，会尽可能的复用已经存在的元素，而不是重新创建新的元素；(这样原来的<code>input</code>元素不再使用，就会直接作为<code>else</code>中的<code>input</code>来使用)</li><li>解决方法：为元素添加<code>key</code>属性，并保证其唯一，这样每次切换时，输入框都将重新被渲染</li></ul><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h5><ul><li>根据表达式的值显示或隐藏元素</li><li>带有<code>v-show</code>的元素始终都会被渲染并保留在<code>DOM</code>中，只是简单的切换元素的<code>CSS</code>属性<code>display</code></li><li>不支持<code>&lt;template&gt;</code>元素，也不支持<code>v-else</code></li></ul><h5 id="v-if-和v-show的区别"><a href="#v-if-和v-show的区别" class="headerlink" title="v-if 和v-show的区别"></a>v-if 和v-show的区别</h5><ul><li><code>v-if</code>是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当的被销毁和重建；同时也是惰性的（如果初始条件为假则不进行渲染，直到条件第一次变为真时才开始渲染条件块）</li><li><code>v-show</code>始终都会渲染</li><li><code>v-if</code>有更高的切换开销，运行条件很少改变时使用；<code>v-show</code>有更高的初始渲染开销，需要频繁切换时使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue初识</title>
      <link href="/2019/11/18/Vue%E5%88%9D%E8%AF%86/"/>
      <url>/2019/11/18/Vue%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><code>Vue</code>是一个渐进式的框架</p><h3 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a><code>Vue</code>中的<code>MVVM</code></h3><ul><li><p><code>View</code>层 视图层，通常就是所说的<code>DOM</code> 层，主要用于给用户展示各种信息</p></li><li><p><code>Model</code>层：数据层，数据可能是固定值，更多的是从服务器请求获得的</p></li><li><p><code>ViewModel</code>层：视图模型层，连接View和Model，一方面实现了<code>Data Binding</code>即数据绑定，将<code>model</code>的改变实时反映到view中；同时也实现了<code>DOM Listener</code>即<code>DOM</code>监听，当<code>DOM</code>发生事件时，可以监听到，并在需要的情况下改变相应的<code>data</code></p><img src="/2019/11/18/Vue%E5%88%9D%E8%AF%86/media\MVVM.jpg" alt="MVVM" style="zoom:50%;"></li></ul><p><code>vue</code>生命周期：</p><img src="/2019/11/18/Vue%E5%88%9D%E8%AF%86/media\Vue-lifecycle.png" alt="Vue生命周期"><p>生命周期函数：<img src="/2019/11/18/Vue%E5%88%9D%E8%AF%86/media\lifecycle.png" alt="lifecycle" style="zoom:80%;"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    message: &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> obj = &#123;</span></span><br><span class="line"><span class="actionscript">        message: <span class="string">'this is content.'</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,            <span class="comment">//指明Vue要控制的区域</span></span></span><br><span class="line">        data: obj,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">//初始化时期</span></span></span><br><span class="line">            beforeCreate() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"beforeCreate"</span>)</span></span><br><span class="line">            &#125;,</span><br><span class="line">            created() &#123;&#125;,</span><br><span class="line">            beforeMount() &#123;&#125;,</span><br><span class="line">            mounted() &#123;&#125;,</span><br><span class="line"><span class="actionscript">            <span class="comment">//更新</span></span></span><br><span class="line">            beforeUpdate() &#123;&#125;,</span><br><span class="line">            updated()&#123;&#125;,</span><br><span class="line"><span class="actionscript">            <span class="comment">//销毁</span></span></span><br><span class="line">            beforeDestory() &#123;&#125;,</span><br><span class="line">            destoryed()&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode中自定义代码模板</title>
      <link href="/2019/11/18/vscode%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/11/18/vscode%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<ol><li>打开setting -&gt; user snippets</li><li>选择需要定义的文件，如：<code>html.json</code></li><li>配置<code>json</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&quot;console&quot;: &#123;</span><br><span class="line">  &quot;prefix&quot;: &quot;log&quot;,</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">      &quot;console.log(&apos;$1&apos;);&quot;,</span><br><span class="line">      &quot;$2&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;description&quot;: &quot;Log output to console&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;vue&quot;: &#123;</span><br><span class="line">  &quot;prefix&quot;: &quot;vue-html&quot;,</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">    &quot;&lt;div id=\&quot;app\&quot;&gt;&quot;,</span><br><span class="line">    &quot;  message: &#123;&#123; message &#125;&#125;&quot;,</span><br><span class="line">    &quot;&lt;/div&gt;&quot;,</span><br><span class="line">    &quot;&lt;script src=\&quot;./vue.js\&quot;&gt;&lt;/script&gt;&quot;,</span><br><span class="line">    &quot;&lt;script&gt;&quot;,</span><br><span class="line">    &quot;  const obj = &#123;&quot;,</span><br><span class="line">    &quot;    message: &apos;this is content.&apos;&quot;,</span><br><span class="line">    &quot;  &#125;&quot;,</span><br><span class="line">    &quot;  const app = new Vue(&#123;&quot;,</span><br><span class="line">    &quot;    el: &apos;#app&apos;,&quot;,</span><br><span class="line">    &quot;    data: obj,&quot;,</span><br><span class="line">    &quot;    methods: &#123;&quot;,</span><br><span class="line">    &quot;      $1&quot;,</span><br><span class="line">    &quot;    &#125;&quot;,</span><br><span class="line">    &quot;  &#125;)&quot;,</span><br><span class="line">    &quot;&lt;/script&gt;&quot;,</span><br><span class="line">  ],</span><br><span class="line">  &quot;description&quot;: &quot;生成带Vue的HTML模板&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在<code>html</code>文件中输入<code>vue-html</code>+ <code>enter</code>即可生成自定义的模板</li><li>注：<code>&quot;prefix&quot;</code>:相当于自定义快捷键；<code>&quot;body&quot;</code>即模板内容；<code>&quot;description&quot;</code>是模板的描述内容;有些属性的双引号冲突用<code>\</code>转义符即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础</title>
      <link href="/2019/11/15/webpack%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/11/15/webpack%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>tips：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install    i</span><br><span class="line">--global   -g</span><br><span class="line">--save-dev  -D</span><br><span class="line">--save   -S</span><br></pre></td></tr></table></figure><ol><li><p>在项目根目录初始化 <code>yarn init -y</code></p></li><li><p>安装到本地 <code>yarn add webpack webpack-cli -D</code></p></li><li><p>webpack4 相对于 3 的最主要的区别是所谓的<code>零配置</code></p><p>打包<code>npx webpack</code> 将src中的代码打包到dist文件夹中main.js</p></li><li><p>手动配置webpack</p><ol><li><p>根目录下新建配置文件：<code>webpack.config.js</code></p></li><li><pre><code class="js"><span class="comment">//webpack based on node, so write in node's style</span><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)<span class="built_in">module</span>.exports = {    <span class="comment">// exist two mode: production  development</span>    mode: <span class="string">'development'</span>,    entry: <span class="string">'./src/index.js'</span>,    output: {        <span class="comment">// must absolute path</span>        path: path.resolve(__dirname, <span class="string">'dist'</span>),        filename: <span class="string">'bundle.js'</span>    }}&lt;!--￼<span class="number">1</span>--&gt;</code></pre></li><li><p>在 <code>package.json</code>文件中进行脚本配置 ，此时打包在终端运行 <code>npm run build</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li></ol></li><li><p>开发调试，使用<code>webpack-dev-server</code>在浏览器中进行调试；它是基于express的node.js服务器，在文件发生改变时，会自动触发打包过程，然后通过<code>Socket.IO</code>通知浏览器刷新页面，可以大大提高工作效率</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack-dev-server -D</span><br><span class="line">  devServer: &#123; <span class="comment">//开发服务器的配置</span></span><br><span class="line">        port: <span class="number">3000</span>, <span class="comment">//指定服务器监听的端口号</span></span><br><span class="line">        progress: <span class="literal">true</span>,</span><br><span class="line">        contentBase: <span class="string">'./build'</span>,<span class="comment">//指定请求的根路径</span></span><br><span class="line">        open: <span class="literal">true</span>,  <span class="comment">//自动打开浏览器</span></span><br><span class="line">        compress: <span class="literal">true</span>  <span class="comment">//启用gzip压缩</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>打包<code>HTML</code>（<code>webpack</code>默认只能打包<code>js</code>文件，所以需要安装插件）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [ <span class="comment">// 放着所有webpack插件</span></span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="comment">// 用于使用模板打包时生成index.html文件，并且在run dev时会将模板文件也打包到内存中</span></span><br><span class="line">    template: <span class="string">'./index.html'</span>, <span class="comment">// 模板文件</span></span><br><span class="line">    filename: <span class="string">'index.[hash:8].html'</span>, <span class="comment">// 打包后生成文件,添加hash戳，防止每次修改后打包的覆盖</span></span><br><span class="line">    hash: <span class="literal">true</span>, <span class="comment">// 添加hash值解决缓存问题</span></span><br><span class="line">    minify: &#123; <span class="comment">// 对打包的html模板进行压缩</span></span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span>, <span class="comment">// 删除属性双引号</span></span><br><span class="line">      collapseWhitespace: <span class="literal">true</span> <span class="comment">// 折叠空行变成一行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>==loader和plugin不同==</p><ul><li><p><code>loader</code>是使<code>webpack</code>拥有加载和解析非 js 文件的能力；</p></li><li><p>plugin 可以扩展webpack 的功能，使webpack更加灵活，可以在构建过程中通过webpack的api改变输出的结果；</p></li></ul></li><li><p>处理<code>CSS</code>文件</p><figure class="highlight plain"><figcaption><span>用来解析```@import```语法，``` style-loader ``` 用于将```css```插入到 ```head```标签中,执行顺序默认从右向左（从下向上），多个使用数组形式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```js</span><br><span class="line">npm i css-loader style-loader -D</span><br><span class="line"></span><br><span class="line">module: &#123;    // 模块</span><br><span class="line">  rules: [   // 规则</span><br><span class="line">    &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader,&apos;css-loader&apos;,  &apos;postcss-loader&apos; ] &#125;,</span><br><span class="line">        /* &#123; //loader也可以写成对象方式,可以添加参数</span><br><span class="line">             loader: &apos;style-loader&apos;,</span><br><span class="line">             options: &#123;</span><br><span class="line">                 insertAt: &apos;top&apos; // 将css标签插入最顶头  这样可以自定义style不被覆盖</span><br><span class="line">             &#125;  */</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>CleanWebpackPlugin</code>插件，在每次构建前清理<code>/dist</code>文件夹，只会生成用到的文件；插件的使用：先引入然后new一个实例，实例可传入参数</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>); <span class="comment">// 引入CleanWebpackPlugin插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'版权所有，翻版必究'</span>),  <span class="comment">// new一个插件的实例 </span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.join(__dirname, <span class="string">"/src/index.template.html"</span>)<span class="comment">// new一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>]),  <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li><p>热更新插件，可以在我们修改代码后自动刷新预览效果。</p><p>使用：</p><figure class="highlight plain"><figcaption><span>参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ```HotModuleReplacementPlugin```是```webpack``` 模块自带的，所以引入后在 ```plugin```配置项中直接使用</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">// webpack.config.js</span><br><span class="line">...</span><br><span class="line">const webpack = require(&apos;webpack&apos;);  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录</span><br><span class="line">        port: &quot;8088&quot;,  // 设置端口号为8088</span><br><span class="line">        inline: true, // 文件修改后实时刷新</span><br><span class="line">        historyApiFallback: true, //不跳转</span><br><span class="line">        hot: true // 热更新</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),  // new一个插件的实例 </span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.join(__dirname, &quot;/src/index.template.html&quot;)// new一个这个插件的实例，并传入相关的参数</span><br><span class="line">        &#125;),</span><br><span class="line">        new CleanWebpackPlugin([&apos;dist&apos;]),  // 传入所要清理的文件夹名称</span><br><span class="line">        new webpack.HotModuleReplacementPlugin() // 热更新插件 </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h4><h5 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h5><p>当前开发环境都提倡模块化，webpack也是</p><p>步骤：</p><ul><li>在根目录下创建三个文件夹分别代表公共配置文件、开发环境配置文件、生产环境（项目上线时的环境）配置文件，<code>webpack.common.js, webpack.dev.js, webpack.prod.js</code></li><li>将<code>webpack.config.js</code>的代码拆分到上述三个文件中，然后将其删除</li><li>修改<code>package.json</code>文件，自定义指向的文件，否则默认<code>webpack.config.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --config webpack.prod.js"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --config webpack.dev.js"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h5 id="多入口多出口"><a href="#多入口多出口" class="headerlink" title="多入口多出口"></a>多入口多出口</h5><p>在<code>webpack.common.js</code>中的<code>entry</code>入口有三种写法，分别为字符串、数组和对象，用得比较多的是对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: path.join(__dirname, <span class="string">"/src/index.js"</span>),</span><br><span class="line">        two: path.join(__dirname, <span class="string">"/src/two.js"</span>)</span><br><span class="line">    &#125;, </span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join( __dirname, <span class="string">"/dist"</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">        filename: <span class="string">"[name].js"</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>npm run build</code>打包后发现<code>/dist</code>文件夹下会多出<code>two.js</code>文件，同时<code>index.html</code>也会自动将<code>two.js</code>引入</p><h5 id="增加css前缀"><a href="#增加css前缀" class="headerlink" title="增加css前缀"></a>增加css前缀</h5><p>在css某些属性前自动加上前缀</p><p>安装模块： <code>npm install postcss-loader autoprefixer -D</code></p><p>项目根目录下新建<code>postcss.config.js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  <span class="comment">// 引用autoprefixer模块</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>webpack.common.js</code>中<code>css-loader</code>配置</p><h5 id="分离css"><a href="#分离css" class="headerlink" title="分离css"></a>分离css</h5><figure class="highlight plain"><figcaption><span>i extract-text-webpack-plugin@next -D```  ```@next```表示安装最新版，并在```webpack.common.js```中引入使用该插件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```js</span><br><span class="line">// webpack.common.js</span><br><span class="line">...</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;) //引入分离插件</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,   // 正则匹配以.css结尾的文件</span><br><span class="line">                use: ExtractTextPlugin.extract(&#123;  // 这里我们需要调用分离插件内的extract方法</span><br><span class="line">                    fallback: &apos;style-loader&apos;,  // 相当于回滚，经postcss-loader和css-loader处理过的css最终再经过style-loader处理</span><br><span class="line">                    use: [&apos;css-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        ...</span><br><span class="line">        new ExtractTextPlugin(&apos;css/index.css&apos;) // 将css分离到/dist文件夹下的css文件中的index.css</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消除冗余css"><a href="#消除冗余css" class="headerlink" title="消除冗余css"></a>消除冗余css</h5><p>重复设置样式，会造成代码的冗余，<code>webpack</code>可以实现优化</p><p>模块安装：<code>cnpm i purifycss-webpack purify-css glob -D</code> 一般会在生产环境中优化，所以在<code>webpack.prod.js</code>文件中进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>); <span class="comment">// 引入CleanWebpackPlugin插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>); <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);  <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;   <span class="comment">// 将webpack.common.js合并到当前文件</span></span><br><span class="line">    devtool: <span class="string">'source-map'</span>,  <span class="comment">// 会生成对于调试的完整的.map文件，但同时也会减慢打包速度</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>]),  <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">        <span class="keyword">new</span> PurifyCssWebpack(&#123;</span><br><span class="line">            paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)) <span class="comment">// 同步扫描所有html文件中所引用的css</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h5><p>要使用图片，需要安装<code>url-loader, file-loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">        ...</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                    fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">                    use: [<span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>],</span><br><span class="line">                    publicPath: <span class="string">'../'</span>  <span class="comment">// 给背景图片设置一个公共路径</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|svg|gif)$/</span>, </span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'url-loader'</span>,  <span class="comment">// 使用url-loader</span></span><br><span class="line">                         options: &#123;</span><br><span class="line">                            limit: <span class="number">10000</span>, <span class="comment">//限制只有小于10kb的图片才转为base64</span></span><br><span class="line">                            outputPath: <span class="string">'images'</span>   <span class="comment">//设置打包后图片存放的文件夹名称</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --config webpack.prod.js --mode production"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --config webpack.dev.js --mode development"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>--mode production</code>表示打包时是生产环境，会自动将js代码进行压缩，<code>--mode development</code>表示当前是开发环境，不需要进行压缩。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn 与 npm 区别</title>
      <link href="/2019/11/15/yarn-%E4%B8%8E-npm-%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/15/yarn-%E4%B8%8E-npm-%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="yarn-与-npm-区别："><a href="#yarn-与-npm-区别：" class="headerlink" title="yarn 与 npm 区别："></a>yarn 与 npm 区别：</h3><ol><li><p>Yarn是facebook发布的一款取代npm的包管理工具；</p></li><li><p>Yarn一开始的主要目标是解决上一节中描述的由于语义版本控制而导致的npm安装的不确定性问题</p></li><li><p>安装yarn<code>npm install -g yarn</code></p></li><li><p><code>yarn init -y</code>  // 快速生成默认的<code>package.json</code>文件，<code>-y</code>即<code>yes</code>省去了敲回车的步骤，等价于 <code>npm init -y</code></p></li><li><p>npm中：“5.0.3”表示安装指定的5.0.3版本，“～5.0.3”表示安装5.0.X中最新的版本，“^5.0.3”表示安装5.X.X中最新的版；npm5.0版本新增package-lock.json，用于锁定模块版本号；yarn会默认生成<code>yarn.lock</code>文件，记录安装模块的版本号，保证每次拉取同一个项目依赖时，使用的都是同一个模块版本；与npm不同的是，yarn无需互联网连接就能安装本地缓存的依赖项，它提供了离线模式；</p></li><li><p>npm 与 yarn命令对比</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install                         yarn</span><br><span class="line">npm install express --save          yarn add express</span><br><span class="line">npm uninstall express --save        yarn remove wxpress</span><br><span class="line">npm install express --save-dev      yarn add react --dev</span><br><span class="line">npm update --save                   yarn upgrade</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>node的path模块中path.resolve()和path.join()的区别</title>
      <link href="/2019/11/15/node%E7%9A%84path%E6%A8%A1%E5%9D%97%E4%B8%ADpath-resolve-%E5%92%8Cpath-join-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/15/node%E7%9A%84path%E6%A8%A1%E5%9D%97%E4%B8%ADpath-resolve-%E5%92%8Cpath-join-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="path模块的引入"><a href="#path模块的引入" class="headerlink" title="path模块的引入"></a>path模块的引入</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path = require('path')</span><br></pre></td></tr></table></figure><h3 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve()"></a>path.resolve()</h3><p>是把一个路径或路径片段的序列解析为一个绝对路径。其处理方式类似于对这些路径逐一进行cd 操作。==对于以/开始的路径片段，<code>path.join</code>只是简单的将其进行拼接，<code>path.resolve</code> 将以/ 开始的路径作为根目录，在此之前的路径将会被丢弃==</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">let</span> path = path.resolve(__dirname, <span class="string">'./src'</span>)</span><br><span class="line"><span class="keyword">let</span> path0 = path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line"><span class="keyword">let</span> path1 = path.resolve(__dirname, <span class="string">'/src'</span>)</span><br><span class="line"><span class="keyword">let</span> path2 = path.resolve(<span class="string">'/foo'</span>,<span class="string">'./src'</span>,<span class="string">'./index.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__dirname) <span class="comment">//e:\test</span></span><br><span class="line"><span class="built_in">console</span>.log(path)  <span class="comment">//e:\test\src</span></span><br><span class="line"><span class="built_in">console</span>.log(path0)  <span class="comment">//e:\test\src</span></span><br><span class="line"><span class="built_in">console</span>.log(path1)  <span class="comment">//e:\src</span></span><br><span class="line"><span class="built_in">console</span>.log(path2)  <span class="comment">///foo/src/index.js</span></span><br></pre></td></tr></table></figure><h3 id="path-join"><a href="#path-join" class="headerlink" title="path.join()"></a>path.join()</h3><p>是将路径片段使用特定的分隔符(<code>window: \</code>,<code>linux: /</code>)连接起来形成路径。并规范化生成的路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">let</span> path1 = path.join(__dirname, <span class="string">'src/index.js'</span>)</span><br><span class="line"><span class="keyword">let</span> path2 = path.join(__dirname, <span class="string">'src'</span>, <span class="string">'foo'</span>, <span class="string">'index.js'</span>,<span class="string">'..'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__dirname) <span class="comment">//e:\test</span></span><br><span class="line"><span class="built_in">console</span>.log(path1)  <span class="comment">//e:\test\src\index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(path2)  <span class="comment">//e:\test\src\foo</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npx和npm区别</title>
      <link href="/2019/11/13/npx%E5%92%8Cnpm%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/13/npx%E5%92%8Cnpm%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<ol><li><p>npm: node.js package manager, 是一款node.js的==包管理工具==；</p><ul><li><p>允许用户从npm服务器下载别人编写的第三方包到本地使用；</p></li><li><p>允许用户从npm服务器下载并安装别人编写的命令程序到本地使用；</p></li><li><p>允许用户将自己写的包或命令行程序上传到npm服务器供别人使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;<span class="built_in">module</span> name&gt;</span><br><span class="line">npm uninstall &lt;<span class="built_in">module</span> name&gt;</span><br><span class="line">npm update xxx</span><br></pre></td></tr></table></figure></li></ul></li><li><p>npx: node.js package execute, 是一个node.js的==包执行工具==。</p><p>npx是一种在npm（5.2.0及以上版本）中的安装工具，亦可以单独下载使用，旨在提高从npm注册表使用软件包的体验，可以不用全局安装create-react-app包，而是用的时候从网上下载避免全局污染。</p><ul><li>在项目中直接运行命令，直接运行node_modules中的某个指令，不需要输入文件路径</li><li>避免全局模块安装：npx临时安装一个模块，使用后删除这个模块</li><li>可以执行仓库中的代码，远程代码必须是一个模块</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>chrome调试模拟慢速3G网络</title>
      <link href="/2019/10/30/chrome%E8%B0%83%E8%AF%95%E6%A8%A1%E6%8B%9F%E6%85%A2%E9%80%9F3G%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/10/30/chrome%E8%B0%83%E8%AF%95%E6%A8%A1%E6%8B%9F%E6%85%A2%E9%80%9F3G%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>F12调试工具==》network ==》 online 选择相应的网速；<br>add用来自定义网速<br><img src="/public/img/Chrome.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中px, em 和 rem 的区别</title>
      <link href="/2019/10/15/css%E4%B8%ADpx,%20em%20%E5%92%8C%20rem%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/10/15/css%E4%B8%ADpx,%20em%20%E5%92%8C%20rem%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>px, em, rem都是计量单位，都表示尺寸；</p><ol><li><p>px 表示‘绝对尺寸’，就是css 中定义的像素；</p><ul><li>利用px设置字体及元素宽高等比较稳定和精确；</li><li>缺点是不能适应浏览器缩放时产生的变化，一般不用于响应式页面</li></ul></li><li><p>em 表示相对尺寸</p><ul><li>其相对于当前对象内文本的font-size（若当前对象内文本的font-size单位也是em，则参照父元素文本font-size）；</li><li>特点可以较好的适应屏幕尺寸的变化；但是设置时需要知道当前对象内文本的font-size或父元素文本的font-size；</li></ul></li><li><p>rem 相对尺寸，其参考对象为根元素<html>的font-size</html></p></li></ol><p>注：像素密度PPI，每英寸的像素个数，</p><p>设备独立像素：保证不同像素密度的设备看上去大小应该差不多，</p><p>物理像素：屏幕渲染图像的最小单位，</p><p>css像素：网页布局的单位，默认在PC端与物理像素一致，可以通过缩放改变其大小</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp</title>
      <link href="/2019/10/10/gulp/"/>
      <url>/2019/10/10/gulp/</url>
      
        <content type="html"><![CDATA[<p><code>gulp</code>是基于<code>Node.js</code>的一个构件工具（自动任务运行器），用于构建自动化工作流程；常见应用：网页自动刷新、css预处理、代码检测。压缩图片等。</p><h3 id="gulp使用步骤"><a href="#gulp使用步骤" class="headerlink" title="gulp使用步骤"></a>gulp使用步骤</h3><ol><li>安装gulp库文件 <code>npm install gulp</code></li><li>在项目根目录下新建文件 <code>gulpfile.js</code></li><li>重构项目的文件夹结构，<code>src</code>:放置源文件代码  <code>dis</code>：放置构建后的文件</li><li>在<code>gulpfile.js</code>中编写任务</li><li>在命令行工具（<code>npm install gulp-cli -g</code>）中执行gulp任务(<code>gulp 任务名</code>)</li></ol><h3 id="gulp中提供的方法"><a href="#gulp中提供的方法" class="headerlink" title="gulp中提供的方法"></a>gulp中提供的方法</h3><ul><li><code>gulp.src()</code> 获取任务要处理的文件</li><li><code>gulp.dest()</code> 输出文件</li><li><code>gulp.task()</code> 建立gulp任务 参数一：任务名称  参数二：回调函数</li><li><code>gulp.watch</code> 监控文件的变化</li><li><code>gulp.run(任务名)</code>：运行任务</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用模块</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立任务 参数一：任务的名称，用以区分各任务 参数二：任务的回调函数</span></span><br><span class="line">gulp.task(<span class="string">'first'</span>, () =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'this is my first gulp task.'</span>)</span><br><span class="line"><span class="comment">// 获取要处理的文件（本例实现将其复制到dist/css/文件夹下，若文件夹不存在则会自动新建）</span></span><br><span class="line">gulp.src(<span class="string">'./src/css/base.css'</span>)</span><br><span class="line">.pipe(gulp.dest(<span class="string">'./dist/css'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="gulp插件"><a href="#gulp插件" class="headerlink" title="gulp插件"></a>gulp插件</h3><ul><li><code>gulp-htmlmin</code> ：html文件压缩</li><li><code>gulp.csso</code>：压缩<code>css</code></li><li><code>gulp-babel</code>：<code>javascript</code>语法转化</li><li><code>gulp-less</code>：<code>less</code>语法转化</li><li><code>gulp-uglify</code>：压缩混淆<code>javascript</code></li><li><code>gulp-file-include</code>：公共文件包含</li><li><code>browsersync</code>：浏览器实时同步</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(<span class="string">'first'</span>,<span class="string">'second'</span>,<span class="string">'thirdcss'</span>,<span class="string">'jsmin'</span>,<span class="string">'copy'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行gulp default命令即可依次后面的多个任务，default可省略</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> gulp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/15/hello-world/"/>
      <url>/2019/09/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ps切图</title>
      <link href="/2019/03/14/ps%E5%88%87%E5%9B%BE/"/>
      <url>/2019/03/14/ps%E5%88%87%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>  文件菜单   – 存储为web设备所用格式 —-   选择  我们要的图片格式 —-  点存储  —   别忘了选中的切片</p><h4 id="辅助线和切片使用及清除"><a href="#辅助线和切片使用及清除" class="headerlink" title="辅助线和切片使用及清除"></a>辅助线和切片使用及清除</h4><p>视图菜单– 清除 辅助线/ 清除切片</p><h3 id="2-切图插件"><a href="#2-切图插件" class="headerlink" title="2). 切图插件"></a>2). 切图插件</h3><p>Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。</p><p>官网: <a href="http://www.cutterman.cn/zh/cutterman" target="_blank" rel="noopener">http://www.cutterman.cn/zh/cutterman</a></p><p>注意： cutterman插件要求你的ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。</p><img src="/2019/03/14/ps%E5%88%87%E5%9B%BE/sample1.gif">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ps </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
